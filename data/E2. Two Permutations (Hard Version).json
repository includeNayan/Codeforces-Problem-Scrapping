{
    "contest_id": "1882",
    "problem_index": "E",
    "title": "E2. Two Permutations (Hard Version)",
    "description": "This is the hard version of the problem. The difference between the two versions is that you have to minimize the number of operations in this version. You can make hacks only if both versions of the problem are solved. You have two permutations † p 1 , p 2 , … , p n (of integers 1 to n ) and q 1 , q 2 , … , q m (of integers 1 to m ). Initially p i = a i for i = 1 , 2 , … , n , and q j = b j for j = 1 , 2 , … , m . You can apply the following operation on the permutations several (possibly, zero) times. In one operation, p and q will change according to the following three steps: You choose integers i , j which satisfy 1 ≤ i ≤ n and 1 ≤ j ≤ m . Permutation p is partitioned into three parts using p i as a pivot: the left part is formed by elements p 1 , p 2 , … , p i − 1 (this part may be empty), the middle part is the single element p i , and the right part is p i + 1 , p i + 2 , … , p n (this part may be empty). To proceed, swap the left and the right parts of this partition. Formally, after this step, p will become p i + 1 , p i + 2 , … , p n , p i , p 1 , p 2 , … , p i − 1 . The elements of the newly formed p will be reindexed starting from 1 . Perform the same transformation on q with index j . Formally, after this step, q will become q j + 1 , q j + 2 , … , q m , q j , q 1 , q 2 , … , q j − 1 . The elements of the newly formed q will be reindexed starting from 1 . Your goal is to simultaneously make p i = i for i = 1 , 2 , … , n , and q j = j for j = 1 , 2 , … , m . Find any way to achieve the goal using the minimum number of operations possible , or say that none exists. Please note that you have to minimize the number of operations. † A permutation of length k is an array consisting of k distinct integers from 1 to k in arbitrary order. For example, [ 2 , 3 , 1 , 5 , 4 ] is a permutation, but [ 1 , 2 , 2 ] is not a permutation ( 2 appears twice in the array), and [ 1 , 3 , 4 ] is also not a permutation ( k = 3 but there is 4 in the array).",
    "input": "Input The first line contains two integers n and m ( 1 ≤ n , m ≤ 2500 ). The second line contains n integers a 1 , a 2 , … , a n ( 1 ≤ a i ≤ n ). The third line contains m integers b 1 , b 2 , … , b m ( 1 ≤ b i ≤ m ). It is guaranteed that a and b are permutations.",
    "output": "Output If there is no solution, print a single integer − 1 . Otherwise, print an integer k — the number of operations to perform, followed by k lines, each containing two integers i and j ( 1 ≤ i ≤ n , 1 ≤ j ≤ m ) — the integers chosen for the operation. If there are multiple solutions, print any of them. Please note that you have to minimize the number of operations.",
    "example": "Examples\nInput\nCopy\n3 5\n2 1 3\n5 2 1 4 3\nOutput\nCopy\n2\n3 4\n2 4\nInput\nCopy\n4 4\n3 4 2 1\n2 4 1 3\nOutput\nCopy\n3\n3 3\n1 4\n4 2\nInput\nCopy\n2 2\n1 2\n2 1\nOutput\nCopy\n-1",
    "note": "Note In the first test case, we can achieve the goal within 2 operations: In the first operation, choose i = 3 , j = 4 . After this, p becomes [ 3 , 2 , 1 ] and q becomes [ 3 , 4 , 5 , 2 , 1 ] . In the second operation, choose i = 2 , j = 4 . After this, p becomes [ 1 , 2 , 3 ] and q becomes [ 1 , 2 , 3 , 4 , 5 ] . In the third test case, it is impossible to achieve the goal.",
    "tags": [
        "constructive algorithms",
        "*3100"
    ],
    "editorial_content": null
}