{
    "contest_id": "2116",
    "problem_index": "A",
    "title": "A. Gellyfish and Tricolor Pansy",
    "description": "Gellyfish and Flower are playing a game called \"Duel\". Gellyfish has a a HP, while Flower has b b HP. Each of them has a knight. Gellyfish's knight has c c HP, while Flower's knight has d d HP. They will play a game in rounds until one of the players wins. For k = 1 , 2 , … k = 1 , 2 , … in this order, they will perform the following actions: If k k is odd and Gellyfish's knight is alive: Gellyfish's knight can attack Flower and reduce b b by 1 1 . If b ≤ 0 b ≤ 0 , Gellyfish wins . Or, Gellyfish's knight can attack Flower's knight and reduce d d by 1 1 . If d ≤ 0 d ≤ 0 , Flower's knight dies. If k k is even and Flower's knight is alive: Flower's knight can attack Gellyfish and reduce a a by 1 1 . If a ≤ 0 a ≤ 0 , Flower wins . Or, Flower's knight can attack Gellyfish's knight and reduce c c by 1 1 . If c ≤ 0 c ≤ 0 , Gellyfish's knight dies. As one of the smartest people in the world, you want to tell them who will win before the game. Assume both players play optimally. It can be proven that the game will never end in a draw. That is, one player has a strategy to end the game in a finite number of moves.",
    "input": "Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 10 4 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first and only line of each test case contains four integers a a , b b , c c , d d ( 1 ≤ a , b , c , d ≤ 10 9 1 ≤ a , b , c , d ≤ 10 9 ) — the HP of Gellyfish, the HP of Flower, the HP of Gellyfish's knight, and the HP of Flower's knight, respectively.",
    "output": "Output For each test case, if Flower will win, output \"Flower\", otherwise output \"Gellyfish\".",
    "example": "Example\nInput\nCopy\n5\n1 2 3 4\n100 999 1 1\n10 20 10 30\n12 14 13 11\n998 244 353 107\nOutput\nCopy\nFlower\nGellyfish\nFlower\nGellyfish\nGellyfish",
    "note": "Note In the first test case, Gellyfish has only 1 1 HP. Therefore, no matter what Gellyfish does in the first round, Flower's knight will attack Gellyfish in the second round, allowing Flower to win. In the second test case, Flower's knight has only 1 1 HP. Gellyfish will attack Flower's knight in the first round. Then Flower's knight will no longer be able to attack, allowing Gellyfish to win.",
    "tags": [
        "games",
        "greedy",
        "*800"
    ],
    "editorial_content": "You could tell people didn't seem to like the match very much. I'm sorry I screwed up again ¯\\_(ツ)_/¯\nIf you're interested, I'd like to share some thoughts I have about this contest.\nsad story\nThis time I've been trying my best to make the problems use more varied algorithms instead of just dp problems, but sadly\n2115C - Gellyfish and Eternal Violet\nwas much harder than expected.\nBut it seems like people are complaining more about the narrow time limit, centered on\n2116C - Gellyfish and Flaming Peony\nand\n2115C - Gellyfish and Eternal Violet\n.\nNo one realized this before the contest, because none of the tester's code is get TLE except the wrong time complexity.\nI actually don't see a problem with the Time Limit of\n2116C - Gellyfish and Flaming Peony\n. Some of you may be puzzled, but let me try to explain this:\nThe intended solution is\nO\n(\n∑\nn\nmax\n(\na\n)\n+\nmax\n(\na\n)\n2\n)\nO\n(\n∑\nn\nmax\n(\na\n)\n+\nmax\n(\na\n)\n2\n)\nand does not contain\nlog\nmax\n(\na\n)\nlog\n⁡\nmax\n(\na\n)\n. Computing\ngcd\n(\nx\n,\ny\n)\ngcd\n(\nx\n,\ny\n)\nis not\nO\n(\n1\n)\nO\n(\n1\n)\n, if you don't preprocess, then it's not unusual to actually get a TLE.\nI believe the vast majority of people who get TLE do so for this reason, and you might argue that it's actually hard to tell whether it's the constant that's too large or the time complexity that's wrong. I would say that normally, if someone expects\nO\n(\nn\n2\nlog\nn\n)\nO\n(\nn\n2\nlog\n⁡\nn\n)\nto pass, then the questioner would set it to\nn\n≤\n2000\nn\n≤\n2000\ninstead of\nn\n≤\n5000\nn\n≤\n5000\n.\nI'll admit that\nn\n,\na\ni\n≤\n2000\nn\n,\na\ni\n≤\n2000\nwould have been better, \"Happy AC\" isn't a bad thing, this is not Div.1 F and we shouldn't limit complexity to such a narrow range. I'm ignoring the fact that most people who get a TLE will assume that the constant is too large, and thus not even think about the large amount of time wasted from optimizing the complexity.\nIf someone's solution is\nO\n(\n∑\nn\nmax\n(\na\n)\n+\nmax\n(\na\n)\n2\n)\nO\n(\n∑\nn\nmax\n(\na\n)\n+\nmax\n(\na\n)\n2\n)\nand it gets TLE, I really don't know why. The speed performance of array accesses on Codeforces is very strange (also happens on\n2115C - Gellyfish and Eternal Violet\n), the vast majority of\nO\n(\n∑\nn\nmax\n(\na\n)\n+\nmax\n(\na\n)\n2\n)\nO\n(\n∑\nn\nmax\n(\na\n)\n+\nmax\n(\na\n)\n2\n)\ncode which gets TLE performs quite well locally, I didn't realize this until after the contest. It's extremely hard for this to happen, I've tried various modifications to std, including swapping the order of the two dimensions of the array and the enumerations i, j, and none of them have gotten a TLE. it's only possible to get a TLE if your code is in an extremely unlucky situation, otherwise going beyond\n1\n1\nsecond is almost impossible if you are using C++.\nFor\n2115C - Gellyfish and Eternal Violet\n, I'll admit it was a huge mistake:\nA\nO\n(\nm\n2\nh\n)\nO\n(\nm\n2\nh\n)\ncode is so fast that it takes less than\n5\n5\nseconds even at today's ranges, It runs so fast that I ignored the constants in order to prevent it from passing. The speed of std and testers' codes gave me too much confidence. (Although it was ultimately discovered that some testers' codes did not encounter the worst-case scenario) I should indeed guarantee\n∑\nn\n≤\n50\n∑\nn\n≤\n50\ninstead of\n∑\nn\n≤\n100\n∑\nn\n≤\n100\n.\nNow I deeply realize that for all but the last few problems, the probability of unintended solutions passing due to extreme constant optimization is far less than the probability of intended solutions receiving TLE. Very few people master instruction sets and extreme constant optimization techniques, and their skill level is usually high enough to handle these problems. The effort required to pass these problems through extreme constant optimization often outweighs simply reconsidering the correct time complexity. I hope the failure of this contest will make future problem authors aware of this issue.\nIn fact, the original constraints for\n2115C - Gellyfish and Eternal Violet\nwere\nn\n≤\n100\n,\nm\n≤\n2000\n,\nh\ni\n≤\n100\nn\n≤\n100\n,\nm\n≤\n2000\n,\nh\ni\n≤\n100\nwhich would have prevented the current situation. If someone passes your problem through extreme constant optimization, think carefully based on the problem's difficulty—whether you should increase the constraints or just give everyone a \"Happy AC.\"\nIn any case, it's all over now. Though this wasn't a perfect ending, 'Life goes on.' Hope Codeforces contests will keep improving, and wish those reading this better results in future competitions.\n2116A - Gellyfish and Tricolor Pansy\nIdea:\nGellyfish\nSolution:\nGellyfish\nPrepared by:\nGellyfish\nHint 1\nPlease think carefully about what happens after the death of either knight.\nSolution\nWhile a player who goes to\n0\n0\nHP will lose the game outright, when a player's knight dies, she loses the ability to attack; then in future rounds, she can only be attacked by her opponent and thus lose the game.\nThus it can be found that the player herself is as important as her knights, and she loses the game when either of them becomes\n0\n0\nHP.\nTherefore, the optimal strategy for both of them is to attack the one with lower HP. So when\nmin\n(\na\n,\nc\n)\nmin\n(\na\n,\nc\n)\nis greater than or equal to\nmin\n(\nb\n,\nd\n)\nmin\n(\nb\n,\nd\n)\n, Gellyfish wins, otherwise Flower wins.\nTime complexity:\nO\n(\n1\n)\nO\n(\n1\n)\nper test case.\nMemory complexity:\nO\n(\n1\n)\nO\n(\n1\n)\nper test case.\nCode\n#include\n<\nbits\n/\nstdc\n++.\nh\n>\nusing\nnamespace\nstd\n;\ninline\nvoid\nsolve\n(){\nint\na\n=\n0\n,\nb\n=\n0\n,\nc\n=\n0\n,\nd\n=\n0\n;\nscanf\n(\n\"%d %d %d %d\"\n,\n&\na\n,\n&\nb\n,\n&\nc\n,\n&\nd\n);\nif\n(\nmin\n(\na\n,\nc\n)\n>=\nmin\n(\nb\n,\nd\n))\nprintf\n(\n\"Gellyfish\\n\"\n);\nelse\nprintf\n(\n\"Flower\\n\"\n);\n}\nint\nT\n=\n0\n;\nint\nmain\n(){\nscanf\n(\n\"%d\"\n,\n&\nT\n);\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nT\n;\ni\n++)\nsolve\n();\nreturn\n0\n;\n}\n2116B - Gellyfish and Baby's Breath\nIdea:\nGellyfish\nSolution:\nGellyfish\nPrepared by:\nGellyfish\nHint 1\nHow to quickly compare\n2\na\n+\n2\nb\n2\na\n+\n2\nb\nand\n2\nc\n+\n2\nd\n2\nc\n+\n2\nd\nfor given integers\na\n,\nb\n,\nc\n,\nd\na\n,\nb\n,\nc\n,\nd\nis the key.\nHint 2\nWe are given two permutations of\np\np\nand\nq\nq\n, which means that each element will appear only once in both\np\np\nand\nq\nq\n, respectively. What's the point of this?\nSolution\nFor given integers\na\n,\nb\n,\nc\n,\nd\na\n,\nb\n,\nc\n,\nd\n, if we want to compare\n2\na\n+\n2\nb\n2\na\n+\n2\nb\nand\n2\nc\n+\n2\nd\n2\nc\n+\n2\nd\n, we actually need to compare\nmax\n(\na\n,\nb\n)\nmax\n(\na\n,\nb\n)\nwith\nmax\n(\nc\n,\nd\n)\nmax\n(\nc\n,\nd\n)\nfirst, and\nmin\n(\na\n,\nb\n)\nmin\n(\na\n,\nb\n)\nwith\nmin\n(\nc\n,\nd\n)\nmin\n(\nc\n,\nd\n)\nsecond. This is due to\n2\nk\n=\n2\nk\n−\n1\n+\n2\nk\n−\n1\n2\nk\n=\n2\nk\n−\n1\n+\n2\nk\n−\n1\n; when\nmax\n(\nc\n,\nd\n)\n<\nmax\n(\na\n,\nb\n)\nmax\n(\nc\n,\nd\n)\n<\nmax\n(\na\n,\nb\n)\n,\n2\nc\n+\n2\nd\n≤\n2\n×\n2\nmax\n(\nc\n,\nd\n)\n≤\n2\nmax\n(\na\n,\nb\n)\n2\nc\n+\n2\nd\n≤\n2\n×\n2\nmax\n(\nc\n,\nd\n)\n≤\n2\nmax\n(\na\n,\nb\n)\n, and it's symmetric for\nmax\n(\na\n,\nb\n)\n<\nmax\n(\nc\n,\nd\n)\nmax\n(\na\n,\nb\n)\n<\nmax\n(\nc\n,\nd\n)\n.\nSo for all\ni\ni\n, we only need to find\nj\n=\narg\nmax\n1\n≤\nl\n≤\ni\np\nl\n,\nk\n=\narg\nmax\n1\n≤\nl\n≤\ni\nq\nl\nj\n=\narg\n⁡\nmax\n1\n≤\nl\n≤\ni\np\nl\n,\nk\n=\narg\n⁡\nmax\n1\n≤\nl\n≤\ni\nq\nl\n, then\nr\ni\n=\nmax\n(\n2\np\nj\n+\n2\nq\ni\n−\nj\n,\n2\np\ni\n−\nk\n+\n2\nq\nk\n)\nr\ni\n=\nmax\n(\n2\np\nj\n+\n2\nq\ni\n−\nj\n,\n2\np\ni\n−\nk\n+\n2\nq\nk\n)\n. This is easily done in\nO\n(\nn\n)\nO\n(\nn\n)\ntime.\nTime complexity:\nO\n(\nn\n)\nO\n(\nn\n)\nper test case.\nMemory complexity:\nO\n(\nn\n)\nO\n(\nn\n)\nper test case.\nCode\n#include\n<\nbits\n/\nstdc\n++.\nh\n>\nusing\nnamespace\nstd\n;\nconst\nint\nN\n=\n1e5\n+\n5\n,\nMod\n=\n998244353\n;\nint\nn\n=\n0\n,\ns\n[\nN\n]\n=\n{},\np\n[\nN\n]\n=\n{},\nq\n[\nN\n]\n=\n{},\nr\n[\nN\n]\n=\n{};\ninline\nvoid\nsolve\n(){\nscanf\n(\n\"%d\"\n,\n&\nn\n);\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nn\n;\ni\n++)\nscanf\n(\n\"%d\"\n,\n&\np\n[\ni\n]);\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nn\n;\ni\n++)\nscanf\n(\n\"%d\"\n,\n&\nq\n[\ni\n]);\nfor\n(\nint\ni\n=\n0\n,\nj\n=\n0\n,\nk\n=\n0\n;\nk\n<\nn\n;\nk\n++){\nif\n(\np\n[\nk\n]\n>\np\n[\ni\n])\ni\n=\nk\n;\nif\n(\nq\n[\nk\n]\n>\nq\n[\nj\n])\nj\n=\nk\n;\nif\n(\np\n[\ni\n]\n!=\nq\n[\nj\n]){\nif\n(\np\n[\ni\n]\n>\nq\n[\nj\n])\nprintf\n(\n\"%d \"\n,\n(\ns\n[\np\n[\ni\n]]\n+\ns\n[\nq\n[\nk\n-\ni\n]])\n%\nMod\n);\nelse\nprintf\n(\n\"%d \"\n,\n(\ns\n[\nq\n[\nj\n]]\n+\ns\n[\np\n[\nk\n-\nj\n]])\n%\nMod\n);\n}\nelse\nprintf\n(\n\"%d \"\n,\n(\ns\n[\np\n[\ni\n]]\n+\ns\n[\nmax\n(\nq\n[\nk\n-\ni\n],\np\n[\nk\n-\nj\n])])\n%\nMod\n);\n}\nprintf\n(\n\"\\n\"\n);\n}\nint\nT\n=\n0\n;\nint\nmain\n(){\ns\n[\n0\n]\n=\n1\n;\nfor\n(\nint\ni\n=\n1\n;\ni\n<\nN\n;\ni\n++)\ns\n[\ni\n]\n=\ns\n[\ni\n-\n1\n]\n*\n2\n%\nMod\n;\nscanf\n(\n\"%d\"\n,\n&\nT\n);\nwhile\n(\nT\n--)\nsolve\n();\nreturn\n0\n;\n}\n2115A - Gellyfish and Flaming Peony\nIdea:\nGellyfish\nSolution:\nGellyfish\nPrepared by:\nGellyfish\nHint 1\nTry to think about why Gellyfish can always achieve her goal, and ultimately what all the elements will turn into.\nHint 2\nWhen you've figured out\nHint 1\n, try using dynamic programming to reach your goal.\nSolution\nLet\ng\n=\ngcd\n(\na\n1\n,\na\n2\n,\n…\n,\na\nn\n)\ng\n=\ngcd\n(\na\n1\n,\na\n2\n,\n…\n,\na\nn\n)\n, It can be shown that eventually all elements become\ng\ng\n.\nConsider the assumption that eventually all numbers are\nx\nx\n. Then for all\ni\ni\n, there is\nx\n|\na\ni\nx\n|\na\ni\n; this is because as\na\ni\n:\n=\ngcd\n(\na\ni\n,\na\nj\n)\na\ni\n:=\ngcd\n(\na\ni\n,\na\nj\n)\n, the new\na\ni\na\ni\nvalue will only be a factor of the original. It further follows that\nx\n|\ng\nx\n|\ng\n.\nFurther analysis reveals that\nx\nx\ncannot be less than\ng\ng\n, no matter how it is manipulated. Thus we have\nx\n=\ng\nx\n=\ng\n.\nNext we consider that after a certain number of operations, if there exists some\na\nk\na\nk\nequal to\ng\ng\n. In the next operations, for each element\na\ni\na\ni\nthat is not equal to\ng\ng\n, we simply choose\nj\n=\nk\nj\n=\nk\nand then make\na\ni\n:\n=\ngcd\n(\na\ni\n,\na\nk\n)\na\ni\n:=\ngcd\n(\na\ni\n,\na\nk\n)\n. After this, all elements will become\ng\ng\n.\nIf\ng\ng\nis initially in\na\na\n, then the problem is simple; we just need to count the number of elements in\na\na\nthat are not equal to\ng\ng\n.\nBut if the initial\ng\ng\nis not in\na\na\n, we are actually trying to make an element equal to\ng\ng\nby minimizing the number of operations.\nThis is not difficult to achieve through dynamic programming, using\nf\nx\nf\nx\nto indicate that it takes at least a few operations to make an element equal to\nx\nx\n.\nThe transition is simple, just enumerate\nx\nx\nfrom largest to smallest, and then for all\ni\ni\n, use\nf\nx\n+\n1\nf\nx\n+\n1\nto update\nf\ngcd\n(\nx\n,\na\ni\n)\nf\ngcd\n(\nx\n,\na\ni\n)\n.\nBut computing\ngcd\n(\nx\n,\ny\n)\ngcd\n(\nx\n,\ny\n)\nis\nO\n(\nlog\nx\n)\nO\n(\nlog\n⁡\nx\n)\n, a direct transition takes\nO\n(\nn\nmax\n(\na\n)\nlog\nmax\n(\na\n)\n)\nO\n(\nn\nmax\n(\na\n)\nlog\n⁡\nmax\n(\na\n)\n)\ntime. So we need to preprocess this. Let\nh\nx\n,\ny\n=\ngcd\n(\nx\n,\ny\n)\nh\nx\n,\ny\n=\ngcd\n(\nx\n,\ny\n)\n, then there is obviously\nh\nx\n,\ny\n=\nh\ny\n,\nx\nmod\ny\nh\nx\n,\ny\n=\nh\ny\n,\nx\nmod\ny\n. Before all test cases,\nh\nh\ncan be preprocessed in\nO\n(\nmax\n(\na\n)\n2\n)\nO\n(\nmax\n(\na\n)\n2\n)\ntime complexity.\nTime complexity:\nO\n(\nn\nmax\n(\na\n)\n)\nO\n(\nn\nmax\n(\na\n)\n)\nper test case and\nO\n(\nmax\n(\na\n)\n2\n)\nO\n(\nmax\n(\na\n)\n2\n)\nfor preprocessing.\nMemory complexity:\nO\n(\nn\n+\nmax\n(\na\n)\n)\nO\n(\nn\n+\nmax\n(\na\n)\n)\nper test case and\nO\n(\nmax\n(\na\n)\n2\n)\nO\n(\nmax\n(\na\n)\n2\n)\nfor preprocessing.\nBonus\nTry to solve\nn\n,\na\ni\n≤\n2\n×\n10\n5\nn\n,\na\ni\n≤\n2\n×\n10\n5\nwith only one test case.\nCode\n#include\n<\nbits\n/\nstdc\n++.\nh\n>\nusing\nnamespace\nstd\n;\nconst\nint\nN\n=\n5000\n+\n5\n;\ninline\nvoid\ncheckmax\n(\nint\n&\nx\n,\nint\ny\n){\nif\n(\ny\n>\nx\n)\nx\n=\ny\n;\n}\ninline\nvoid\ncheckmin\n(\nint\n&\nx\n,\nint\ny\n){\nif\n(\ny\n<\nx\n)\nx\n=\ny\n;\n}\nint\nn\n=\n0\n,\nm\n=\n0\n,\nk\n=\n0\n,\na\n[\nN\n]\n=\n{},\nf\n[\nN\n]\n=\n{};\nint\ng\n[\nN\n][\nN\n]\n=\n{},\nans\n=\n0\n;\ninline\nvoid\nsolve\n(){\nscanf\n(\n\"%d\"\n,\n&\nn\n);\nm\n=\nk\n=\n0\n;\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++){\nscanf\n(\n\"%d\"\n,\n&\na\n[\ni\n]);\nk\n=\ng\n[\nk\n][\na\n[\ni\n]];\n}\nmemset\n(\nf\n,\n0x3f\n,\nsizeof\n(\nf\n));\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++)\na\n[\ni\n]\n/=\nk\n,\ncheckmax\n(\nm\n,\na\n[\ni\n]),\nf\n[\na\n[\ni\n]]\n=\n0\n;\nfor\n(\nint\nx\n=\nm\n;\nx\n>=\n1\n;\nx\n--)\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++){\nint\ny\n=\na\n[\ni\n];\ncheckmin\n(\nf\n[\ng\n[\nx\n][\ny\n]],\nf\n[\nx\n]\n+\n1\n);\n}\nans\n=\nmax\n(\nf\n[\n1\n]\n-\n1\n,\n0\n);\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++)\nif\n(\na\n[\ni\n]\n>\n1\n)\nans\n++;\nprintf\n(\n\"%d\\n\"\n,\nans\n);\n}\nint\nT\n=\n0\n;\nint\nmain\n(){\nfor\n(\nint\nx\n=\n0\n;\nx\n<\nN\n;\nx\n++)\ng\n[\nx\n][\n0\n]\n=\ng\n[\n0\n][\nx\n]\n=\ng\n[\nx\n][\nx\n]\n=\nx\n;\nfor\n(\nint\nx\n=\n1\n;\nx\n<\nN\n;\nx\n++)\nfor\n(\nint\ny\n=\n1\n;\ny\n<\nx\n;\ny\n++)\ng\n[\nx\n][\ny\n]\n=\ng\n[\ny\n][\nx\n]\n=\ng\n[\ny\n][\nx\n%\ny\n];\nscanf\n(\n\"%d\"\n,\n&\nT\n);\nwhile\n(\nT\n--)\nsolve\n();\nreturn\n0\n;\n}\n2115B - Gellyfish and Camellia Japonica\nIdea:\nGellyfish\nSolution:\nGellyfish\nPrepared by:\nGellyfish\nHint 1\nTry working backwards from the final sequence, to the initial.\nHint 2\nIf you're confused about\nHint 1\n, it's probably because the result isn't unique each time. Think carefully about whether you can just take the \"tightest\" result possible\nSolution\nLet's think of the problem in another way, if we only require that for all\ni\ni\n, the final value of\nc\ni\nc\ni\nis greater than or equal to\nb\ni\nb\ni\n, what will be the limitations for all\na\ni\na\ni\n?\nIt is possible to prove that the restricted form exists as a sequence\nl\nl\n. It is sufficient that\na\ni\n≥\nl\ni\na\ni\n≥\nl\ni\nfor all\ni\ni\n.\nNext we try to illustrate this thing, we need to work backward from the last operation and observe the restrictions on\nc\nc\nin each step. After the last operation, we have\nc\ni\n≥\nb\ni\nc\ni\n≥\nb\ni\n, which means\nl\n=\nb\nl\n=\nb\n.\nConsider an operation that replaces\nc\nz\nc\nz\nwith\nmin\n(\nc\nx\n,\nc\ny\n)\nmin\n(\nc\nx\n,\nc\ny\n)\n. If for a post-operation restriction of\nl\nl\n, can we recover the pre-operation restriction\nl\n′\nl\n′\n? Let us think as follows:\nIt is not difficult to find that for\ni\n∉\nx\n,\ny\n,\nz\ni\n∉\nx\n,\ny\n,\nz\n,\nl\n′\ni\n=\nl\ni\nl\ni\n′\n=\nl\ni\n.\nl\n′\nz\n=\n0\nl\nz\n′\n=\n0\n, because the\nc\nz\nc\nz\nbefore the operation is overwritten, it will not actually have any restrictions.\nl\n′\nx\n=\nmax\n(\nl\nx\n,\nl\nz\n)\n,\nl\n′\ny\n=\nmax\n(\nl\ny\n,\nl\nz\n)\nl\nx\n′\n=\nmax\n(\nl\nx\n,\nl\nz\n)\n,\nl\ny\n′\n=\nmax\n(\nl\ny\n,\nl\nz\n)\n. Since the new\nc\nz\nc\nz\nis the original\nmin\n(\nc\nx\n,\nc\ny\n)\nmin\n(\nc\nx\n,\nc\ny\n)\n, it can be found that for the original\nc\nx\nc\nx\n, we have\nc\nx\n≥\nmin\n(\nc\nx\n,\nc\ny\n)\n=\nc\nz\n≥\nl\nz\nc\nx\n≥\nmin\n(\nc\nx\n,\nc\ny\n)\n=\nc\nz\n≥\nl\nz\n, while for\ny\ny\nis symmetric.\nWe have thus proved that, according to the eventually obtained\nl\nl\n,\na\ni\n≥\nl\ni\na\ni\n≥\nl\ni\nfor all\ni\ni\nis a sufficient condition to eventually make all\nc\ni\n≥\nb\ni\nc\ni\n≥\nb\ni\nfor all\ni\ni\n.\nAnd ultimately all\nc\ni\n=\nb\ni\nc\ni\n=\nb\ni\n, thus for all\ni\ni\n,\na\ni\n≥\nl\ni\na\ni\n≥\nl\ni\nis necessary. In fact, we could just take\na\n=\nl\na\n=\nl\nand do all the operations sequentially to see if we end up with\nc\n=\nb\nc\n=\nb\n. This is because as\na\na\ndecreases, eventually\nc\nc\ndecreases as well, and by the\nl\nl\nguarantee there is always\nc\ni\n≥\nb\ni\nc\ni\n≥\nb\ni\n, so in effect we are trying to minimize all of\nc\nc\n, and then minimizing all of\na\na\nis clearly an optimal decision.\nTime complexity:\nO\n(\nn\n+\nq\n)\nO\n(\nn\n+\nq\n)\nper test case.\nMemory complexity:\nO\n(\nn\n+\nq\n)\nO\n(\nn\n+\nq\n)\nper test case.\nCode\n#include\n<\nbits\n/\nstdc\n++.\nh\n>\nusing\nnamespace\nstd\n;\nconst\nint\nN\n=\n3e5\n+\n5\n;\nint\nn\n=\n0\n,\nq\n=\n0\n,\na\n[\nN\n]\n=\n{},\nb\n[\nN\n]\n=\n{},\nc\n[\nN\n]\n=\n{};\nint\nx\n[\nN\n]\n=\n{},\ny\n[\nN\n]\n=\n{},\nz\n[\nN\n]\n=\n{};\ninline\nvoid\ninit\n(){\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++)\na\n[\ni\n]\n=\nb\n[\ni\n]\n=\nc\n[\ni\n]\n=\n0\n;\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nq\n;\ni\n++)\nx\n[\ni\n]\n=\ny\n[\ni\n]\n=\nz\n[\ni\n]\n=\n0\n;\nn\n=\nq\n=\n0\n;\n}\ninline\nvoid\nsolve\n(){\ncin\n>>\nn\n>>\nq\n;\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++){\ncin\n>>\nb\n[\ni\n];\nc\n[\ni\n]\n=\nb\n[\ni\n];\n}\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nq\n;\ni\n++)\ncin\n>>\nx\n[\ni\n]\n>>\ny\n[\ni\n]\n>>\nz\n[\ni\n];\nfor\n(\nint\ni\n=\nq\n;\ni\n>=\n1\n;\ni\n--){\nint\nv\n=\nc\n[\nz\n[\ni\n]];\nc\n[\nz\n[\ni\n]]\n=\n0\n;\nc\n[\nx\n[\ni\n]]\n=\nmax\n(\nc\n[\nx\n[\ni\n]],\nv\n),\nc\n[\ny\n[\ni\n]]\n=\nmax\n(\nc\n[\ny\n[\ni\n]],\nv\n);\n}\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++)\na\n[\ni\n]\n=\nc\n[\ni\n];\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nq\n;\ni\n++)\nc\n[\nz\n[\ni\n]]\n=\nmin\n(\nc\n[\nx\n[\ni\n]],\nc\n[\ny\n[\ni\n]]);\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++)\nif\n(\nb\n[\ni\n]\n!=\nc\n[\ni\n]){\ncout\n<<\n\"-1\\n\"\n;\nreturn\n;\n}\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++)\ncout\n<<\na\n[\ni\n]\n<<\n' '\n;\ncout\n<<\n'\\n'\n;\n}\nint\nT\n=\n0\n;\nint\nmain\n(){\nios\n::\nsync_with_stdio\n(\n0\n);\ncin\n.\ntie\n(\n0\n),\ncout\n.\ntie\n(\n0\n);\ncin\n>>\nT\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nT\n;\ni\n++)\ninit\n(),\nsolve\n();\nreturn\n0\n;\n}\n2115C - Gellyfish and Eternal Violet\nIdea:\nGellyfish\nSolution:\nGellyfish\nPrepared by:\nGellyfish\nHint 1\nTry to find an\nO\n(\nn\nm\nh\n2\n)\nO\n(\nn\nm\nh\n2\n)\nsolution using dynamic programming.\nHint 2\nRe-examining Gellyfish's strategy, there are definitely situations where she chooses to carry out an attack. Can we divide the\nm\nm\nrounds into two phases by some nature?\nSolution\nConsidering all current monsters, if the lowest HP of the monsters is\nl\nl\n, Gellyfish can only make at most\nl\n−\n1\nl\n−\n1\n\"ranged\" attacks.\nSo for each monster, if its HP is\nh\ni\nh\ni\n, then it must be subject to at least\nh\ni\n−\nl\nh\ni\n−\nl\n\"pointing\" attacks. Further, we can see that we only care about\nl\nl\nand\n∑\ni\n=\n1\nn\n(\nh\ni\n−\nl\n)\n∑\ni\n=\n1\nn\n(\nh\ni\n−\nl\n)\n.\nConsider directly using\nf\ni\n,\nl\n,\nx\nf\ni\n,\nl\n,\nx\nto indicate that there are still\ni\ni\nrounds to go, the lowest HP of the monsters is\nl\nl\n, and\nx\n=\n∑\ni\n=\n1\nn\n(\nh\ni\n−\nl\n)\nx\n=\n∑\ni\n=\n1\nn\n(\nh\ni\n−\nl\n)\n, the probability that Gellyfish will reach her goal. This solves the problem within\nO\n(\nn\nm\nh\n2\n)\nO\n(\nn\nm\nh\n2\n)\n, but that's not enough.\nConsider the initial HP of all monsters, let\nl\n=\nmin\ni\n=\n1\nn\nh\ni\n,\ns\n=\n∑\ni\n=\n1\nn\n(\nh\ni\n−\nl\n)\nl\n=\nmin\ni\n=\n1\nn\nh\ni\n,\ns\n=\n∑\ni\n=\n1\nn\n(\nh\ni\n−\nl\n)\n. For the first\ns\ns\ntimes the sword doesn't shine, Gellyfish will obviously launch an attack.\nSo we using\ng\ni\n,\nj\ng\ni\n,\nj\nto indicate the probability that the sword did not shine exactly\nj\nj\ntimes in the first\ni\ni\nrounds and the last time the sword did not shine. We then enumerate the\ns\ns\n-th time that the sword didn't shine. We can divide the problem into two parts. The first half can be solved using\ng\ng\n, while the second half can be solved using\nf\nf\n, We just need to merge the results of the two parts, which is not difficult.\nWhen we use f to solve the second part, it is easy to see that initially all monsters have the same HP, and each \"pointing\" attack can directly attacks the monster with the highest HP, which doesn't make the answer worse. So we have\nh\ni\n−\nl\n≤\n1\nh\ni\n−\nl\n≤\n1\nfor any time, and the range of\nx\nx\nthat we actually need is compressed to\n[\n0\n,\nn\n)\n[\n0\n,\nn\n)\n.\nTime complexity:\nO\n(\nn\nm\nh\n)\nO\n(\nn\nm\nh\n)\nper test case.\nMemory complexity:\nO\n(\nn\nm\nh\n)\nO\n(\nn\nm\nh\n)\nper test case.\nCode\n#include\n<\nbits\n/\nstdc\n++.\nh\n>\nusing\nnamespace\nstd\n;\nconst\nint\nN\n=\n22\n,\nK\n=\n4000\n+\n5\n,\nM\n=\n400\n+\n5\n,\nInf\n=\n0x3f3f3f3f\n;\ninline\nvoid\ncheckmin\n(\ndouble\n&\nx\n,\ndouble\ny\n){\nif\n(\ny\n<\nx\n)\nx\n=\ny\n;\n}\nint\nn\n=\n0\n,\nm\n=\n0\n,\ns\n=\n0\n,\nk\n=\n0\n,\np0\n=\n0\n,\nh\n[\nN\n]\n=\n{};\ndouble\np\n=\n0\n,\nf\n[\nK\n][\nK\n]\n=\n{},\ng\n[\nK\n][\nN\n][\nM\n]\n=\n{},\nans\n=\n0\n;\ninline\nvoid\ninit\n(){\nfor\n(\nint\ni\n=\n0\n;\ni\n<=\nk\n;\ni\n++){\nfor\n(\nint\nc\n=\n0\n;\nc\n<\nn\n;\nc\n++)\nfor\n(\nint\nx\n=\n0\n;\nx\n<=\nm\n;\nx\n++)\ng\n[\ni\n][\nc\n][\nx\n]\n=\n0\n;\nfor\n(\nint\nx\n=\n0\n;\nx\n<=\ns\n;\nx\n++)\nf\n[\ni\n][\nx\n]\n=\n0\n;\n}\nm\n=\nInf\n,\ns\n=\n0\n,\nans\n=\n0\n;\n}\ninline\nvoid\nsolve\n(){\nscanf\n(\n\"%d %d %d\"\n,\n&\nn\n,\n&\nk\n,\n&\np0\n);\np\n=\n1.0\n*\np0\n/\n100\n;\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++){\nscanf\n(\n\"%d\"\n,\n&\nh\n[\ni\n]);\nh\n[\ni\n]\n--;\nm\n=\nmin\n(\nm\n,\nh\n[\ni\n]);\n}\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nn\n;\ni\n++)\ns\n+=\nh\n[\ni\n]\n-\nm\n;\nif\n(\ns\n>\nk\n){\nprintf\n(\n\"0.000000\\n\"\n);\nreturn\n;\n}\ng\n[\n0\n][\n0\n][\n0\n]\n=\n1\n;\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nk\n;\ni\n++){\ng\n[\ni\n][\n0\n][\n0\n]\n=\n1\n;\nfor\n(\nint\nx\n=\n1\n;\nx\n<=\nm\n;\nx\n++)\ng\n[\ni\n][\n0\n][\nx\n]\n=\ng\n[\ni\n-\n1\n][\n0\n][\nx\n-\n1\n]\n*\np\n+\nmax\n(\ng\n[\ni\n-\n1\n][\n0\n][\nx\n],\ng\n[\ni\n-\n1\n][\nn\n-\n1\n][\nx\n-\n1\n])\n*\n(\n1\n-\np\n);\nfor\n(\nint\nc\n=\n1\n;\nc\n<\nn\n;\nc\n++){\ng\n[\ni\n][\nc\n][\n0\n]\n=\ng\n[\ni\n-\n1\n][\nc\n][\n0\n]\n*\np\n+\ng\n[\ni\n-\n1\n][\nc\n-\n1\n][\n0\n]\n*\n(\n1\n-\np\n);\nfor\n(\nint\nx\n=\n1\n;\nx\n<=\nm\n;\nx\n++)\ng\n[\ni\n][\nc\n][\nx\n]\n=\ng\n[\ni\n-\n1\n][\nc\n][\nx\n-\n1\n]\n*\np\n+\ng\n[\ni\n-\n1\n][\nc\n-\n1\n][\nx\n]\n*\n(\n1\n-\np\n);\n}\n}\nf\n[\n0\n][\n0\n]\n=\n1\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nk\n;\ni\n++)\nfor\n(\nint\nx\n=\n0\n;\nx\n<\ns\n;\nx\n++){\nf\n[\ni\n+\n1\n][\nx\n]\n+=\nf\n[\ni\n][\nx\n]\n*\np\n;\nf\n[\ni\n+\n1\n][\nx\n+\n1\n]\n+=\nf\n[\ni\n][\nx\n]\n*\n(\n1\n-\np\n);\n}\nfor\n(\nint\ni\n=\ns\n;\ni\n<=\nk\n;\ni\n++){\ndouble\nr\n=\n0\n;\nfor\n(\nint\nx\n=\n0\n;\nx\n<=\nmin\n(\ni\n-\ns\n,\nm\n)\n;\nx\n++)\nr\n=\nmax\n(\nr\n,\ng\n[\nk\n-\ni\n][\n0\n][\nm\n-\nx\n]);\nans\n+=\nr\n*\nf\n[\ni\n][\ns\n];\n}\nprintf\n(\n\"%.6lf\\n\"\n,\nans\n);\n}\nint\nT\n=\n0\n;\nint\nmain\n(){\nscanf\n(\n\"%d\"\n,\n&\nT\n);\nwhile\n(\nT\n--)\ninit\n(),\nsolve\n();\nreturn\n0\n;\n}\n2115D - Gellyfish and Forget-Me-Not\nIdea:\nMagicalFlower\nSolution:\nMagicalFlower\nPrepared by:\nMagicalFlower\nHint 1\nConsider if\nc\nc\nconsists only of\n0\n0\n, this problem turned out to be another classic problem. So you need at least something that you know what it is.\nHint 2\n\"linear basis\" is the answer to\nHint 1\n. Please try to understand this: all addition operations are interpreted as XOR operations.\nSolution\nWe can assume that the initial value of\nx\nx\nis\n∑\na\ni\n∑\na\ni\n. In each step, we can choose to add\nc\ni\n=\na\ni\n+\nb\ni\nc\ni\n=\na\ni\n+\nb\ni\nto\nx\nx\n, or do nothing. Each suffix of the sequence can be seen as a subproblem, so we prove inductively that the answer, as a function\nf\n(\nx\n)\nf\n(\nx\n)\nof the initial value of\nx\nx\n, is an affine transformation, i.e.,\nf\n(\nx\n)\n=\nA\nx\n+\nb\nf\n(\nx\n)\n=\nA\nx\n+\nb\n.\nWhen\nn\n=\n0\nn\n=\n0\n, this is trivial:\nf\n(\nx\n)\n=\nx\nf\n(\nx\n)\n=\nx\n.\nWhen\nn\n>\n1\nn\n>\n1\n, we can choose to add\nc\ni\nc\ni\nto\nx\nx\nor not. Let\nf\n(\nx\n)\nf\n(\nx\n)\ndenote the answer function from the second operation onward. The two possible outcomes correspond to:\nNot choosing\nc\ni\nc\ni\n: result is\nf\n(\nx\n)\nf\n(\nx\n)\nChoosing\nc\ni\nc\ni\n: result is\nf\n(\nx\n+\nc\ni\n)\n=\nf\n(\nx\n)\n+\nf\n(\nc\ni\n)\n+\nb\nf\n(\nx\n+\nc\ni\n)\n=\nf\n(\nx\n)\n+\nf\n(\nc\ni\n)\n+\nb\n.\nAlthough we don't know the exact value of\nx\nx\n,\nf\n(\nc\ni\n)\n+\nb\nf\n(\nc\ni\n)\n+\nb\nis a constant. Suppose the highest set bit in the binary representation of\nf\n(\nc\ni\n)\n+\nb\nf\n(\nc\ni\n)\n+\nb\nis at position\nk\nk\n. Then, the decision of whether to apply this operation depends only on:\nWhether we want to maximize or minimize the final answer\nWhether the\nk\nk\n-th bit of\nf\n(\nx\n)\nf\n(\nx\n)\nis\n0\n0\nor\n1\n1\nIt is easy to observe that the new function\ng\n(\nx\n)\ng\n(\nx\n)\n(before this decision) remains a affine transformation, satisfying\ng\n(\nx\n)\n=\ng\n(\nx\n+\nc\ni\n)\ng\n(\nx\n)\n=\ng\n(\nx\n+\nc\ni\n)\n.\nBased on the above process, we can represent the answer function\nf\n(\nx\n)\nf\n(\nx\n)\nusing a orthogonal basis. Each element in the orthogonal basis represents a vector in the null space of\nA\nA\n. Additionally, we keep a tag for each vector, indicating whether it is used to increase or decrease the value of\nx\nx\n.\nIn each iteration, we try to insert\nc\ni\nc\ni\ninto the linear basis, and associate it with a tag depending on the index\ni\ni\n.\nTime complexity:\nO\n(\nn\nlog\nmax\n(\na\n,\nb\n,\nx\n)\n)\nO\n(\nn\nlog\n⁡\nmax\n(\na\n,\nb\n,\nx\n)\n)\nper test case.\nMemory complexity:\nO\n(\nn\n+\nlog\nmax\n(\na\n,\nb\n,\nx\n)\n)\nO\n(\nn\n+\nlog\n⁡\nmax\n(\na\n,\nb\n,\nx\n)\n)\nper test case.\nCode\n#include\n<\nbits\n/\nstdc\n++.\nh\n>\nusing\ni64\n=\nlong\nlong\n;\nconstexpr\nint\nL\n=\n60\n;\nint\nmain\n()\n{\nstd\n::\nios\n::\nsync_with_stdio\n(\nfalse\n),\nstd\n::\ncin\n.\ntie\n(\n0\n);\nint\nT\n;\nfor\n(\nstd\n::\ncin\n>>\nT\n;\nT\n;\nT\n--)\n{\nint\nn\n;\nstd\n::\ncin\n>>\nn\n;\nstd\n::\nvector\n<i64>\na\n(\nn\n),\nb\n(\nn\n);\nstd\n::\nstring\nstr\n;\ni64 all\n=\n0\n;\nfor\n(\nauto\n&\nx\n:\na\n)\nstd\n::\ncin\n>>\nx\n,\nall\n^=\nx\n;\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nn\n;\ni\n++)\n{\nstd\n::\ncin\n>>\nb\n[\ni\n];\nb\n[\ni\n]\n^=\na\n[\ni\n];\n}\nstd\n::\ncin\n>>\nstr\n;\nstd\n::\nvector\n<i64>\nbas\n(\nL\n);\nstd\n::\nvector\n<int>\nbel\n(\nL\n,\n-\n1\n);\ni64 ans\n=\n0\n;\nfor\n(\nint\ni\n=\nn\n-\n1\n;\ni\n>=\n0\n;\ni\n--)\n{\ni64 x\n=\nb\n[\ni\n],\ncol\n=\nstr\n[\ni\n]\n-\n'0'\n;\nfor\n(\nint\ni\n=\nL\n-\n1\n;\ni\n>=\n0\n;\ni\n--)\nif\n(\nx\n>>\ni\n&\n1\n)\n{\nif\n(\nbas\n[\ni\n])\n{\nx\n^=\nbas\n[\ni\n];\n}\nelse\n{\nfor\n(\nint\nj\n=\ni\n-\n1\n;\nj\n>=\n0\n;\nj\n--)\nif\n(\nx\n>>\nj\n&\n1\n)\n{\nx\n^=\nbas\n[\nj\n];\n}\nbas\n[\ni\n]\n=\nx\n;\nfor\n(\nint\nj\n=\nL\n-\n1\n;\nj\n>\ni\n;\nj\n--)\nif\n(\nbas\n[\nj\n]\n>>\ni\n&\n1\n){\nbas\n[\nj\n]\n^=\nbas\n[\ni\n];\n}\nbel\n[\ni\n]\n=\ncol\n;\nbreak\n;\n}\n}\n}\nfor\n(\nint\ni\n=\nL\n-\n1\n;\ni\n>=\n0\n;\ni\n--)\nif\n(\nall\n>>\ni\n&\n1\n)\n{\nall\n^=\nbas\n[\ni\n];\n}\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nL\n;\ni\n++)\nif\n(\nbel\n[\ni\n]\n==\n1\n)\nans\n^=\nbas\n[\ni\n];\nstd\n::\ncout\n<<\n(\nall\n^\nans\n)\n<<\n'\\n'\n;\n}\nreturn\n0\n;\n}\n2115E - Gellyfish and Mayflower\nIdea:\nGellyfish\nSolution:\nGellyfish\nPrepared by:\nGellyfish\nHint 1\nThere is an easy way to solve the problem in\nO\n(\nm\nmax\n(\nr\n)\n+\nq\n)\nO\n(\nm\nmax\n(\nr\n)\n+\nq\n)\ntime complexity. Thus for cases with small\nr\nr\n, we can easily solve them, but what about cases with large\nr\nr\n?\nHint 2\nThere is a classic but mistaken greed where we only take the item with the largest\nw\nc\nw\nc\n. This is obviously wrong, but\nHint 1\nlets us rule out the case where r is small; is there an efficient algorithm that can fix this greed for larger\nr\nr\n?\nSolution\nLet\ns\ns\nbe any path from vertex\n1\n1\nto vertex\np\np\n, the vertices that pass through in turn are\ns\n1\n,\ns\n2\n,\n…\n,\ns\nk\ns\n1\n,\ns\n2\n,\n…\n,\ns\nk\n.\nLet\nz\nz\nbe the vertex in\ns\ns\nwith the largest\nw\nc\nw\nc\n, and $C = c_z, W = w_z$​.\nLet's call your cards you don't get from vertex\nz\nz\nas special cards.\nLemma1.\nThere exists an optimal solution such that the number of special cards does not exceed\nC\nC\n.\nProof.\nLet\nc\n′\n1\n,\nc\n′\n2\n,\n…\n,\nc\n′\nk\n′\nc\n1\n′\n,\nc\n2\n′\n,\n…\n,\nc\nk\n′\n′\nbe the cost of the special cards, and\np\n′\ni\n=\n∑\ni\nj\n=\n1\nc\n′\nj\np\ni\n′\n=\n∑\nj\n=\n1\ni\nc\n′\nj\n. If there exists\n0\n≤\nl\n<\nr\n≤\nk\n′\n,\np\n′\nl\n≡\np\n′\nr\nmod\nC\n0\n≤\nl\n<\nr\n≤\nk\n′\n,\np\nl\n′\n≡\np\nr\n′\nmod\nC\n, we will get that\n∑\nr\n′\ni\n=\nl\n′\n+\n1\np\ni\n≡\n0\nmod\nC\n∑\ni\n=\nl\n′\n+\n1\nr\n′\np\ni\n≡\n0\nmod\nC\n. Then we can replaces these cards with\n∑\nr\n′\ni\n=\nl\n′\n+\n1\np\ni\nC\n∑\ni\n=\nl\n′\n+\n1\nr\n′\np\ni\nC\ncards from vertex\nz\nz\n, the answer won't be worse. Since there are only\nC\n+\n1\nC\n+\n1\nvalues of\nx\nmod\nC\nx\nmod\nC\nfor all non-negative integers\nx\nx\n, there are no more than\nC\nC\nspecial cards.\nSo it's not hard to find the total cost of special cards won't exceed\nmax\n(\nc\n)\n2\nmax\n(\nc\n)\n2\n.\nNow we can use dynamic programming to solve this problem:\nd\np\n(\nu\n,\nv\n,\nx\n,\n0\n/\n1\n)\nd\np\n(\nu\n,\nv\n,\nx\n,\n0\n/\n1\n)\nmeans we are current at vertex\nu\nu\n, the vertex on the path with the largest\nw\nc\nw\nc\nis\nv\nv\n, the total cost of the cards is\nx\nx\n, we have reached the vertex\nv\nv\nor not, the maximum sum of the power of the cards.\nSince the remainder will be filled by cards from\nv\nv\n, We just need to find the value of\nd\np\n(\nu\n,\nv\n,\nx\n)\nd\np\n(\nu\n,\nv\n,\nx\n)\nthat satisfies\n1\n≤\nx\n≤\nmax\n(\nc\n)\n2\n1\n≤\nx\n≤\nmax\n(\nc\n)\n2\n.\nBut unfortunately, the time complexity of the algorithm is\nO\n(\nm\nn\nmax\n(\nc\n)\n2\n)\nO\n(\nm\nn\nmax\n(\nc\n)\n2\n)\n. It's not fast enough.\nAt this point you'll find that solving the problem directly becomes incredibly tricky, so we'll try to split it into two problems.\nWe first consider the following problem: whether there is a better solution when\nr\nr\nis sufficiently large?\nWe need to broaden the problem, so we try to be able to buy a negative number of cards with the largest\nw\nc\nw\nc\n.\nDoing so would make the answer larger, but when\nr\nr\nis large enough, the answer won't change. Because according to\nLemma1\n, if the total cost of special cards exceed\nmax\n(\nc\n)\n2\nmax\n(\nc\n)\n2\n, there will be a solution that's at least not worse.\nThus when\nr\n>\nmax\n(\nc\n)\n2\nr\n>\nmax\n(\nc\n)\n2\n, that's the answer of the problem. And we can use another dynamic programming to solve this problem:\ng\n(\nu\n,\nv\n,\nx\n,\n0\n/\n1\n)\ng\n(\nu\n,\nv\n,\nx\n,\n0\n/\n1\n)\nmeans we are current at vertex\nu\nu\n, the vertex on the path with the largest\nw\nc\nw\nc\nis\nv\nv\n, the total cost of the cards is\nx\nx\n, we have reached the vertex\nv\nv\nor not, the maximum sum of the power of the cards.\nBut unlike the original, when\nx\nx\nis equal to or greater than\nc\nv\nc\nv\n, we remove several cards from vertex\nv\nv\nto make\n0\n≤\nx\n<\nc\nv\n0\n≤\nx\n<\nc\nv\n.\nThe time complexity becomes\nO\n(\nm\nn\nmax\n(\nc\n)\n)\nO\n(\nm\nn\nmax\n(\nc\n)\n)\n, now it's fast enough.\nFor each query, we can just enumerate\nv\nv\nin\nO\n(\nn\n)\nO\n(\nn\n)\ntime complexity.\nAs for\nr\n≤\nm\na\nx\n(\nc\n)\n2\nr\n≤\nm\na\nx\n(\nc\n)\n2\n? It's an easy problem:\nf\n(\nu\n,\nx\n)\nf\n(\nu\n,\nx\n)\nmeans we are current at vertex\nu\nu\n, the total cost of the cards is\nx\nx\n, the maximum sum of the power of the cards.\nThe time complexity is\nO\n(\nm\nmax\n(\nc\n)\n2\n)\n​\nO\n(\nm\nmax\n(\nc\n)\n2\n)\n​\n.\nFor each query, we can get the answer directly from\nf\nf\nin\nO\n(\n1\n)\nO\n(\n1\n)\ntime complexity.\nOver all, we have solved the problem.\nTime complexity:\nO\n(\nm\nn\nmax\n(\nc\n)\n+\nm\nmax\n(\nc\n)\n2\n+\nq\nn\n)\nO\n(\nm\nn\nmax\n(\nc\n)\n+\nm\nmax\n(\nc\n)\n2\n+\nq\nn\n)\nMemory complexity:\nO\n(\nn\n2\nmax\n(\nc\n)\n+\nn\nmax\n(\nc\n)\n2\n)\nO\n(\nn\n2\nmax\n(\nc\n)\n+\nn\nmax\n(\nc\n)\n2\n)\nCode\n#include\n<\nbits\n/\nstdc\n++.\nh\n>\nusing\nnamespace\nstd\n;\ntypedef\nlong\nlong\nll\n;\nconst\nll N\n=\n200\n+\n5\n,\nInf\n=\n0xcfcfcfcfcfcfcfcf\n;\ninline\nll sqr\n(\nll x\n){\nreturn\nx\n*\nx\n;\n}\ninline\nll gcd\n(\nll x\n,\nll y\n){\nif\n(\ny\n)\nreturn\ngcd\n(\ny\n,\nx\n%\ny\n);\nelse\nreturn\nx\n;\n}\ninline\nvoid\ncheckmax\n(\nll\n&\nx\n,\nll y\n){\nif\n(\ny\n>\nx\n)\nx\n=\ny\n;\n}\nll n\n=\n0\n,\nm\n=\n0\n,\nmagic\n=\n0\n,\nw\n[\nN\n]\n=\n{},\nc\n[\nN\n]\n=\n{};\nll f\n[\nN\n][\nN\n*\nN\n]\n=\n{},\ng\n[\nN\n][\nN\n][\nN\n][\n2\n]\n=\n{};\nvector\n<\nvector\n<ll>\n>\nG\n(\nN\n);\ninline\nvoid\nmain_min\n(){\nmemset\n(\nf\n,\n0xcf\n,\nsizeof\n(\nf\n));\nfor\n(\nll x\n=\n0\n;\nx\n<=\nmagic\n;\nx\n++)\nf\n[\n1\n][\nx\n]\n=\n0\n;\nfor\n(\nll u\n=\n1\n;\nu\n<=\nn\n;\nu\n++){\nfor\n(\nll x\n=\n0\n;\nx\n+\nc\n[\nu\n]\n<=\nmagic\n;\nx\n++)\ncheckmax\n(\nf\n[\nu\n][\nx\n+\nc\n[\nu\n]],\nf\n[\nu\n][\nx\n]\n+\nw\n[\nu\n]);\nfor\n(\nll v\n:\nG\n[\nu\n])\nfor\n(\nll x\n=\n0\n;\nx\n<=\nmagic\n;\nx\n++)\ncheckmax\n(\nf\n[\nv\n][\nx\n],\nf\n[\nu\n][\nx\n]);\n}\n}\ninline\nvoid\nsolve_max\n(\nll i\n){\nll a\n=\nc\n[\ni\n],\nb\n=\nw\n[\ni\n];\nfor\n(\nll x\n=\n0\n;\nx\n<\na\n;\nx\n++)\ng\n[\ni\n][\n1\n][\nx\n][\n0\n]\n=\n0\n;\nfor\n(\nll u\n=\n1\n;\nu\n<=\nn\n;\nu\n++){\nif\n(\nu\n==\ni\n)\nfor\n(\nll x\n=\n0\n;\nx\n<\na\n;\nx\n++)\ncheckmax\n(\ng\n[\ni\n][\nu\n][\nx\n][\n1\n],\ng\n[\ni\n][\nu\n][\nx\n][\n0\n]);\nelse\nif\n(\nw\n[\nu\n]\n*\na\n>\nc\n[\nu\n]\n*\nb\n)\nmemset\n(\ng\n[\ni\n][\nu\n],\n0xcf\n,\nsizeof\n(\ng\n[\ni\n][\nu\n]));\nfor\n(\nll s\n=\n0\n,\nk\n=\ngcd\n(\nc\n[\nu\n],\na\n)\n;\ns\n<\nk\n;\ns\n++)\nfor\n(\nll x\n=\ns\n,\nt\n=\n0\n;\nt\n<\n2\n*\n(\na\n/\nk\n)\n;\nx\n=\n(\nx\n+\nc\n[\nu\n])\n%\na\n,\nt\n++){\ncheckmax\n(\ng\n[\ni\n][\nu\n][(\nx\n+\nc\n[\nu\n])\n%\na\n][\n0\n],\ng\n[\ni\n][\nu\n][\nx\n][\n0\n]\n+\nw\n[\nu\n]\n-\n((\nx\n+\nc\n[\nu\n])\n/\na\n)\n*\nb\n);\ncheckmax\n(\ng\n[\ni\n][\nu\n][(\nx\n+\nc\n[\nu\n])\n%\na\n][\n1\n],\ng\n[\ni\n][\nu\n][\nx\n][\n1\n]\n+\nw\n[\nu\n]\n-\n((\nx\n+\nc\n[\nu\n])\n/\na\n)\n*\nb\n);\n}\nfor\n(\nll v\n:\nG\n[\nu\n])\nfor\n(\nll x\n=\n0\n;\nx\n<\na\n;\nx\n++){\ncheckmax\n(\ng\n[\ni\n][\nv\n][\nx\n][\n0\n],\ng\n[\ni\n][\nu\n][\nx\n][\n0\n]);\ncheckmax\n(\ng\n[\ni\n][\nv\n][\nx\n][\n1\n],\ng\n[\ni\n][\nu\n][\nx\n][\n1\n]);\n}\n}\n}\ninline\nvoid\nmain_max\n(){\nmemset\n(\ng\n,\n0xcf\n,\nsizeof\n(\ng\n));\nfor\n(\nll i\n=\n1\n;\ni\n<=\nn\n;\ni\n++)\nsolve_max\n(\ni\n);\n}\nint\nmain\n(){\nscanf\n(\n\"%lld %lld\"\n,\n&\nn\n,\n&\nm\n);\nfor\n(\nll i\n=\n1\n;\ni\n<=\nn\n;\ni\n++){\nscanf\n(\n\"%lld %lld\"\n,\n&\nc\n[\ni\n],\n&\nw\n[\ni\n]);\nmagic\n=\nmax\n(\nmagic\n,\nsqr\n(\nc\n[\ni\n]));\n}\nfor\n(\nll i\n=\n1\n,\nu\n=\n0\n,\nv\n=\n0\n;\ni\n<=\nm\n;\ni\n++){\nscanf\n(\n\"%lld %lld\"\n,\n&\nu\n,\n&\nv\n);\nG\n[\nu\n].\npush_back\n(\nv\n);\n}\nmain_min\n(),\nmain_max\n();\nll q\n=\n0\n,\np\n=\n0\n,\nr\n=\n0\n;\nscanf\n(\n\"%lld\"\n,\n&\nq\n);\nwhile\n(\nq\n--){\nscanf\n(\n\"%lld %lld\"\n,\n&\np\n,\n&\nr\n);\nif\n(\nr\n<=\nmagic\n)\nprintf\n(\n\"%lld\\n\"\n,\nf\n[\np\n][\nr\n]);\nelse\n{\nll ans\n=\nInf\n;\nfor\n(\nll i\n=\n1\n;\ni\n<=\nn\n;\ni\n++){\nll a\n=\nc\n[\ni\n],\nb\n=\nw\n[\ni\n];\ncheckmax\n(\nans\n,\ng\n[\ni\n][\np\n][\nr\n%\na\n][\n1\n]\n+\n(\nr\n/\na\n)\n*\nb\n);\n}\nprintf\n(\n\"%lld\\n\"\n,\nans\n);\n}\n}\nreturn\n0\n;\n}\n2115F1 - Gellyfish and Lycoris Radiata (Easy Version)\nIdea:\nGellyfish\nUser Solution:\nJ\noesSR\n,\nzhaohaikun\nPrepared by:\nMagicalFlower\nSolution\nWe apply block decomposition to the operations, dividing every\nB\nB\noperations into a single round. Within each round, the sequence is partitioned into\nO\n(\nB\n)\nO\n(\nB\n)\nsegments. For each segment, we maintain a queue that records all elements added to that segment during the round.\nType 1 and 2 operations can be handled directly by pushing into the appropriate segment’s queue or toggling a reversal flag.\nType 3 (deletion) is handled by marking the element\nx\nx\nas deleted without immediately removing it from queues.\nAt the end of each round, we rebuild the sequence. Specifically, for each position in the sequence, we record which segment it belongs to, and treat the position as containing all elements currently in that segment's queue.\nFor queries, we process the contribution from each round one by one. In each round:\nIdentify the segment that contains position\np\np\n.\nIterate through the queue of that segment.\nFor each element, if it has been marked as deleted, remove it from the front of the queue and continue; otherwise, consider it as present.\nSince each element is inserted and deleted at most once per segment, and each segment has\nO\n(\n1\n)\nO\n(\n1\n)\namortized processing per round, the total cost per query remains efficient.\nWe choose\nB\n=\nq\n√\nB\n=\nq\n, resulting in\nO\n(\nq\n√\n)\nO\n(\nq\n)\nrounds in total. The total time and space complexity is:\nO\n(\n(\nn\n+\nq\n)\nq\n√\n)\nO\n(\n(\nn\n+\nq\n)\nq\n)\nCode (by zhaohaikun)\n#pragma\nGCC optimize\n(\n2\n)\n#pragma\nGCC optimize\n(\n\"Ofast\"\n)\n#pragma\nGCC optimize\n(\n\"inline\"\n,\n\"fast-math\"\n,\n\"unroll-loops\"\n,\n\"no-stack-protector\"\n)\n#pragma\nGCC diagnostic error\n\"-fwhole-program\"\n#pragma\nGCC diagnostic error\n\"-fcse-skip-blocks\"\n#pragma\nGCC diagnostic error\n\"-funsafe-loop-optimizations\"\n// MagicDark\n#include\n<\nbits\n/\nstdc\n++.\nh\n>\n#define\ndebug cerr\n<<\n\"\\33[32m[\"\n<<\n__LINE__\n<<\n\"]\\33[m \"\n#define\nSZ\n(\nx\n)\n((\nint\n)\nx\n.\nsize\n()\n-\n1\n)\n#define\nall\n(\nx\n)\nx\n.\nbegin\n(),\nx\n.\nend\n()\n#define\nms\n(\nx\n,\ny\n)\nmemset\n(\nx\n,\ny\n,\nsizeof\nx\n)\n#define\nF\n(\ni\n,\nx\n,\ny\n)\nfor\n(\nint\ni\n=\n(\nx\n);\ni\n<=\n(\ny\n);\ni\n++)\n#define\nDF\n(\ni\n,\nx\n,\ny\n)\nfor\n(\nint\ni\n=\n(\nx\n);\ni\n>=\n(\ny\n);\ni\n--)\nusing\nnamespace\nstd\n;\ntypedef\nlong\nlong\nll\n;\ntypedef\nunsigned\nlong\nlong\null\n;\ntemplate\n<\ntypename\nT\n>\nT\n&\nchkmax\n(\nT\n&\nx\n,\nT y\n)\n{\nreturn\nx\n=\nmax\n(\nx\n,\ny\n);}\ntemplate\n<\ntypename\nT\n>\nT\n&\nchkmin\n(\nT\n&\nx\n,\nT y\n)\n{\nreturn\nx\n=\nmin\n(\nx\n,\ny\n);}\n// template <typename T> T& read(T &x) {\n// \tx = 0; int f = 1; char c = getchar();\n// \tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n// \tfor (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n// \treturn x *= f;\n// }\n// bool be;\nconst\nint\nN\n=\n1e5\n+\n1010\n,\nB\n=\n500\n,\nB1\n=\nN\n/\nB\n+\n5\n,\nB2\n=\nB\n+\n5\n;\nint\nn\n,\nq\n,\nans\n,\np\n[\nN\n],\nwp\n[\nN\n],\ntot\n,\nt\n[\nN\n],\ntl\n[\nN\n],\ntr\n[\nN\n];\nbool\nrev\n[\nN\n];\nbool\ned\n[\nN\n];\n// bool vv[N];\n// struct Q1 {\n// \tint tl = 1, tr;\n// \tint a[B2];\n// \tbool chk() {\n// \t\treturn tl <= tr;\n// \t}\n// \tint front() {\n// \t\treturn a[tl];\n// \t}\n// \tvoid pop() {\n// \t\ttl++;\n// \t}\n// \tvoid push(int x) {\n// \t\ta[++tr] = x;\n// \t}\n// } tq[N];\n// struct Q2 {\n// \tint tl = 1, tr;\n// \tint a[B1];\n// \tbool chk() {\n// \t\treturn tl <= tr;\n// \t}\n// \tint front() {\n// \t\treturn a[tl];\n// \t}\n// \tvoid pop() {\n// \t\ttl++;\n// \t}\n// \tvoid push(int x) {\n// \t\ta[++tr] = x;\n// \t}\n// } vq[N];\nqueue\n<int>\ntq\n[\nN\n],\nvq\n[\nN\n];\nvector\n<int>\ncur\n;\nint\nqq\n(\nint\nx\n)\n{\nwhile\n(\ntq\n[\nx\n].\nsize\n())\n{\nif\n(!\ned\n[\ntq\n[\nx\n].\nfront\n()])\nreturn\ntq\n[\nx\n].\nfront\n();\ntq\n[\nx\n].\npop\n();\n}\nreturn\n0\n;\n}\nint\nquery\n(\nint\nx\n)\n{\nint\ns\n=\n0\n;\nfor\n(\nint\ni\n:\ncur\n)\n{\ns\n+=\ntr\n[\ni\n]\n-\ntl\n[\ni\n]\n+\n1\n;\nif\n(\ns\n>=\nx\n)\n{\nint\ng\n=\ns\n-\nx\n+\n1\n;\nint\ny\n;\nif\n(\nrev\n[\ni\n])\n{\ny\n=\np\n[\ntl\n[\ni\n]\n+\ng\n-\n1\n];\n}\nelse\n{\ny\n=\np\n[\ntr\n[\ni\n]\n-\ng\n+\n1\n];\n}\nwhile\n(\nvq\n[\ny\n].\nsize\n())\n{\nint\ntmp\n=\nqq\n(\nvq\n[\ny\n].\nfront\n());\nif\n(\ntmp\n)\nreturn\ntmp\n;\nvq\n[\ny\n].\npop\n();\n}\n// int tmp = qq(i);\n// if (~tmp) return tmp;\nreturn\nqq\n(\ni\n);\n}\n}\nassert\n(\nfalse\n);\n// return -1;\n}\n// bool ee;\n// int cnt = 0;\nsigned\nmain\n()\n{\nios\n::\nsync_with_stdio\n(\n0\n);\n// don't use puts\ncin\n.\ntie\n(\n0\n),\ncout\n.\ntie\n(\n0\n);\n// debug << abs(&ee - &be) / 1024 / 1024 << endl;\ncin\n>>\nn\n>>\nq\n;\nF\n(\ni\n,\n1\n,\nn\n)\np\n[\ni\n]\n=\ni\n;\ncur\n.\npush_back\n(++\ntot\n);\ntl\n[\n1\n]\n=\n1\n,\ntr\n[\n1\n]\n=\nn\n;\nF\n(\ni\n,\n1\n,\nq\n)\n{\nint\nf\n,\nx\n,\ny\n;\ncin\n>>\nf\n>>\nx\n>>\ny\n;\nif\n(\nf\n==\n3\n)\n{\nx\n=\n(\nx\n+\nans\n-\n1\n)\n%\nq\n+\n1\n;\n}\nelse\n{\nx\n=\n(\nx\n+\nans\n-\n1\n)\n%\nn\n+\n1\n;\n}\ny\n=\n(\ny\n+\nans\n-\n1\n)\n%\nn\n+\n1\n;\n// auto split = [&] (int x) {\n// \tif (x > n || vv[x]) return;\n// \t// vv[x] = true;\n// \tfor (auto [])\n// };\nif\n(\nf\n==\n1\n)\n{\nint\ns\n=\n0\n;\nfor\n(\nint\nj\n:\ncur\n)\n{\nint\nw\n=\ntr\n[\nj\n]\n-\ntl\n[\nj\n]\n+\n1\n;\ns\n+=\nw\n;\nif\n(\ns\n>=\nx\n)\n{\nif\n(\ns\n>\nx\n)\n{\ntot\n++;\ntq\n[\ntot\n]\n=\ntq\n[\nj\n];\nint\ng\n=\ns\n-\nx\n;\nif\n(\nrev\n[\ntot\n]\n=\nrev\n[\nj\n])\n{\ntl\n[\ntot\n]\n=\ntl\n[\nj\n];\ntr\n[\ntot\n]\n=\n(\ntl\n[\nj\n]\n+=\ng\n)\n-\n1\n;\n}\nelse\n{\ntr\n[\ntot\n]\n=\ntr\n[\nj\n];\ntl\n[\ntot\n]\n=\n(\ntr\n[\nj\n]\n-=\ng\n)\n+\n1\n;\n}\ncur\n.\ninsert\n(\nnext\n(\nfind\n(\nall\n(\ncur\n),\nj\n)),\ntot\n);\n}\ntq\n[\nj\n].\npush\n(\ni\n);\nbreak\n;\n}\ntq\n[\nj\n].\npush\n(\ni\n);\n}\n}\nif\n(\nf\n==\n2\n)\n{\nint\ns\n=\n0\n,\nsz\n=\n0\n;\nfor\n(\nint\nj\n:\ncur\n)\n{\nsz\n++;\nint\nw\n=\ntr\n[\nj\n]\n-\ntl\n[\nj\n]\n+\n1\n;\ns\n+=\nw\n;\nif\n(\ns\n>=\nx\n)\n{\nif\n(\ns\n>\nx\n)\n{\ntot\n++;\ntq\n[\ntot\n]\n=\ntq\n[\nj\n];\nint\ng\n=\ns\n-\nx\n;\nif\n(\nrev\n[\ntot\n]\n=\nrev\n[\nj\n])\n{\ntl\n[\ntot\n]\n=\ntl\n[\nj\n];\ntr\n[\ntot\n]\n=\n(\ntl\n[\nj\n]\n+=\ng\n)\n-\n1\n;\n}\nelse\n{\ntr\n[\ntot\n]\n=\ntr\n[\nj\n];\ntl\n[\ntot\n]\n=\n(\ntr\n[\nj\n]\n-=\ng\n)\n+\n1\n;\n}\ncur\n.\ninsert\n(\nnext\n(\nfind\n(\nall\n(\ncur\n),\nj\n)),\ntot\n);\n}\nreverse\n(\ncur\n.\nbegin\n(),\ncur\n.\nbegin\n()\n+\nsz\n);\nF\n(\nj\n,\n0\n,\nsz\n-\n1\n)\nrev\n[\ncur\n[\nj\n]]\n^=\ntrue\n;\nbreak\n;\n}\n}\n}\nif\n(\nf\n==\n3\n)\n{\nif\n(\nx\n<\ni\n)\ned\n[\nx\n]\n=\ntrue\n;\n}\ncout\n<<\n(\nans\n=\nquery\n(\ny\n))\n<<\n'\\n'\n;\nif\n(\ncur\n.\nsize\n()\n>=\nB\n)\n{\nint\ncnt\n=\n0\n;\nfor\n(\nint\nj\n:\ncur\n)\n{\nif\n(\nrev\n[\nj\n])\n{\nDF\n(\nk\n,\ntr\n[\nj\n],\ntl\n[\nj\n])\n{\nvq\n[\nwp\n[++\ncnt\n]\n=\np\n[\nk\n]].\npush\n(\nj\n);\n}\n}\nelse\n{\nF\n(\nk\n,\ntl\n[\nj\n],\ntr\n[\nj\n])\n{\nvq\n[\nwp\n[++\ncnt\n]\n=\np\n[\nk\n]].\npush\n(\nj\n);\n}\n}\n}\nF\n(\nj\n,\n1\n,\nn\n)\n{\np\n[\nj\n]\n=\nwp\n[\nj\n];\n}\ncur\n.\nclear\n();\ncur\n.\npush_back\n(++\ntot\n);\ntl\n[\ntot\n]\n=\n1\n,\ntr\n[\ntot\n]\n=\nn\n;\n}\n// for (int j: cur) {\n// \tdebug << tl[j] << \" \" << tr[j] << \" \" << rev[j] << endl;\n// }\n}\nreturn\n0\n;\n}\n2115F2 - Gellyfish and Lycoris Radiata (Hard Version)\nIdea:\nGellyfish\nFull Solution:\ne\nrrorgorn\nPrepared by:\nMagicalFlower\nSolution\nWe consider using leafy persistent balanced trees to maintain the sequence. At each non-leaf node, we store a set\nS\nu\nS\nu\nas a lazy tag, indicating that every set in the subtree rooted at\nu\nu\ncontains\nS\nu\nS\nu\n. However, since\n|\nS\nu\n|\n|\nS\nu\n|\ncan be large, it's difficult to push down the tag efficiently.\nTo address this, we split each set\nS\nu\nS\nu\ninto two components:\nT\nu\nT\nu\n: A part of\nS\nu\nS\nu\nstored directly at node\nu\nu\nA collection of child nodes\nv\nu\n,\n1\n,\nv\nu\n,\n2\n,\n⋯\n,\nv\nu\n,\nk\nv\nu\n,\n1\n,\nv\nu\n,\n2\n,\n⋯\n,\nv\nu\n,\nk\n, each storing a subset of\nS\nu\nS\nu\nWe maintain the invariant:\nS\nu\n=\nT\nu\n+\n∑\nk\ni\n=\n1\nS\nv\nu\n,\ni\nS\nu\n=\nT\nu\n+\n∑\ni\n=\n1\nk\nS\nv\nu\n,\ni\n.\nThus, we make the balanced tree persistent. When we create a new node\nu\nu\nand initialize its children as\nl\ns\n(\nu\n)\nl\ns\n(\nu\n)\nand\nr\ns\n(\nu\n)\nr\ns\n(\nu\n)\n, we add\nu\nu\ninto both\nv\nl\ns\n(\nu\n)\nv\nl\ns\n(\nu\n)\nand\nv\nr\ns\n(\nu\n)\nv\nr\ns\n(\nu\n)\n. During split and merge, we do not modify\nT\nu\nT\nu\n, which ensures these operations still run in logarithmic time.\nType 1 (Insert):  We split the balanced tree into two parts. Let the root of the first part be\nr\nt\nr\nt\n, and simply add an element into\nT\nr\nt\nT\nr\nt\n.\nType 2 (Reverse a segment):  Just mark the root of the relevant subtree with a \"reverse\" flag.\nType 3 (Delete):  Since each element\nx\nx\nappears in only one\nT\nT\n, we can directly remove it from that node's\nT\nT\n.\nFor queries, We first locate the leaf node\nu\nu\n. To compute\nS\nu\nS\nu\n, we need to compute all\nS\nv\nu\n,\ni\nS\nv\nu\n,\ni\n. Due to persistence, we can guarantee:\nmax\n(\nS\nv\nu\n,\ni\n)\n<\nmin\n(\nS\nv\nu\n,\ni\n+\n1\n)\nmax\n(\nS\nv\nu\n,\ni\n)\n<\nmin\n(\nS\nv\nu\n,\ni\n+\n1\n)\nThus, we can sequentially check whether each\nS\nv\nu\n,\ni\nS\nv\nu\n,\ni\nis empty.\nWe process this recursively. Every time we encounter a node\nx\nx\nwith\nS\nx\n=\n∅\nS\nx\n=\n∅\nand\nx\nx\nis not part of the latest tree version, then\nS\nx\nS\nx\nwill always be empty, and we can safely delete\nx\nx\n. During a query, we encounter three types of nodes:\nNodes with\n|\nS\nx\n|\n≠\n0\n|\nS\nx\n|\n≠\n0\n: We only encounter one such node per query — this is where we find the minimum value.\nNodes with\n|\nS\nx\n|\n=\n0\n|\nS\nx\n|\n=\n0\nand\nx\nx\nnot in the latest tree: These nodes are deleted. Since the total number of persistent nodes is\nO\n(\nq\nlog\nn\n)\nO\n(\nq\nlog\n⁡\nn\n)\n, these nodes also appear at most that many times.\nNodes with\n|\nS\nx\n|\n=\n0\n|\nS\nx\n|\n=\n0\nand\nx\nx\nin the latest tree: These are ancestors of leaf\nu\nu\n, so there are at most\nO\n(\nlog\nn\n)\nO\n(\nlog\n⁡\nn\n)\nof them per query.\nWhy can we just do\nO\n(\nlog\nn\n)\nO\n(\nlog\n⁡\nn\n)\nrounds of recursion? Because we replace all the nodes we pass through on the path, so the size of the subtree doesn't change from the time the node is created to the time it is removed from the tree. Furthermore, if we recurse from node\nu\nu\nto node\nv\nv\n, this means that\nv\nv\nis the parent of\nu\nu\nat least at some point on the WBLT. Since the WBLT is weight-balanced, the size of the\nv\nv\nsubtree is actually at least a constant multiple of the size of the\nu\nu\nsubtree, and this constant greater than\n1\n1\nwill be based on your WBLT.\nTime complexity:\nO\n(\nq\nlog\nn\n+\nn\n)\nO\n(\nq\nlog\n⁡\nn\n+\nn\n)\n.\nMemory complexity:\nO\n(\nq\nlog\nn\n+\nn\n)\nO\n(\nq\nlog\n⁡\nn\n+\nn\n)\n.\nCode\n#include\n<\nbits\n/\nstdc\n++.\nh\n>\nconstexpr\nint\nN\n=\n3e5\n+\n10\n,\nS\n=\n1.1e7\n,\nSS\n=\n2\n*\nS\n;\nint\nn\n,\nq\n;\nint\nnext\n[\nSS\n],\nval\n[\nSS\n],\ncnt\n;\nstruct\nqueue\n{\nint\nhead\n,\ntail\n;\nvoid\npush\n(\nint\nx\n)\n{\nif\n(\nhead\n)\n{\nnext\n[\ntail\n]\n=\n++\ncnt\n,\nval\n[\ncnt\n]\n=\nx\n;\ntail\n=\ncnt\n;\n}\nelse\n{\nhead\n=\ntail\n=\n++\ncnt\n,\nval\n[\ncnt\n]\n=\nx\n;\n}\nassert\n(\ncnt\n<\nSS\n-\n100\n);\n}\nvoid\npop\n()\n{\nhead\n=\nnext\n[\nhead\n];}\nint\nfront\n()\n{\nreturn\nval\n[\nhead\n];}\nbool\ncheck\n()\n{\nreturn\nhead\n==\ntail\n;}\nbool\nempty\n()\n{\nreturn\nhead\n==\n0\n;}\nvoid\nclear\n()\n{\nhead\n=\ntail\n=\n0\n;}\n};\nstruct\nnode\n{\nint\nls\n,\nrs\n;\nqueue fa\n;\nint\nval\n,\nexit\n;\nint\nsize\n,\nrev\n;\n}\na\n[\nS\n];\nint\ntot\n;\nint\nid\n[\nN\n];\nvoid\npushup\n(\nint\nu\n)\n{\na\n[\nu\n].\nsize\n=\na\n[\na\n[\nu\n].\nls\n].\nsize\n+\na\n[\na\n[\nu\n].\nrs\n].\nsize\n;\n}\nvoid\nsetR\n(\nint\nu\n)\n{\na\n[\nu\n].\nrev\n^=\n1\n;\nstd\n::\nswap\n(\na\n[\nu\n].\nls\n,\na\n[\nu\n].\nrs\n);\n}\nvoid\nsetT\n(\nint\nu\n,\nint\nv\n)\n{\na\n[\nu\n].\nfa\n.\npush\n(\nv\n);\n}\nvoid\npushdown\n(\nint\nu\n)\n{\nif\n(\na\n[\nu\n].\nrev\n)\n{\nsetR\n(\na\n[\nu\n].\nls\n);\nsetR\n(\na\n[\nu\n].\nrs\n);\na\n[\nu\n].\nrev\n=\n0\n;\n}\n}\nint\nnewnode\n()\n{\nint\nu\n=\n++\ntot\n;\na\n[\nu\n].\nexit\n=\n2\n;\nreturn\nu\n;\n}\nint\nnewleaf\n()\n{\nint\nu\n=\nnewnode\n();\na\n[\nu\n].\nsize\n=\n1\n;\nreturn\nu\n;\n}\nint\njoin\n(\nint\nx\n,\nint\ny\n)\n{\nint\nu\n=\nnewnode\n();\na\n[\nu\n].\nls\n=\nx\n,\na\n[\nu\n].\nrs\n=\ny\n;\na\n[\nx\n].\nfa\n.\npush\n(\nu\n);\na\n[\ny\n].\nfa\n.\npush\n(\nu\n);\npushup\n(\nu\n);\nreturn\nu\n;\n}\nauto\ncut\n(\nint\nx\n)\n{\npushdown\n(\nx\n);\na\n[\nx\n].\nexit\n=\n1\n;\nreturn\nstd\n::\nmake_pair\n(\na\n[\nx\n].\nls\n,\na\n[\nx\n].\nrs\n);\n}\nint\nget_val\n(\nint\nu\n)\n{\nif\n(\na\n[\nu\n].\nexit\n==\n0\n)\nreturn\n0\n;\nif\n(\na\n[\nu\n].\nval\n!=\n0\n)\nreturn\na\n[\nu\n].\nval\n;\nif\n(\na\n[\nu\n].\nfa\n.\nempty\n())\nreturn\n0\n;\nint\nans\n=\n0\n;\nwhile\n(\n1\n)\n{\nans\n=\nget_val\n(\na\n[\nu\n].\nfa\n.\nfront\n());\nif\n(\nans\n)\nreturn\nans\n;\nif\n(\na\n[\nu\n].\nfa\n.\ncheck\n())\nbreak\n;\na\n[\nu\n].\nfa\n.\npop\n();\n}\nif\n(\na\n[\nu\n].\nexit\n==\n1\n)\n{\na\n[\nu\n].\nexit\n=\n0\n;\na\n[\nu\n].\nfa\n.\npop\n();\na\n[\nu\n].\nfa\n.\nclear\n();\n}\nreturn\n0\n;\n}\nint\nnewtag\n(\nint\nx\n)\n{\nint\nu\n=\n++\ntot\n;\na\n[\nu\n].\nval\n=\nx\n;\na\n[\nu\n].\nexit\n=\n1\n;\nreturn\nu\n;\n}\nconstexpr\ndouble\nALPHA\n=\n0.292\n;\nbool\ntoo_heavy\n(\nint\nsx\n,\nint\nsy\n)\n{\nreturn\nsy\n<\nALPHA\n*\n(\nsx\n+\nsy\n);\n}\nint\nmerge\n(\nint\nx\n,\nint\ny\n)\n{\nif\n(!\nx\n||\n!\ny\n)\nreturn\nx\n+\ny\n;\nif\n(\ntoo_heavy\n(\na\n[\nx\n].\nsize\n,\na\n[\ny\n].\nsize\n))\n{\nauto\n[\nu\n,\nv\n]\n=\ncut\n(\nx\n);\nif\n(\ntoo_heavy\n(\na\n[\nv\n].\nsize\n+\na\n[\ny\n].\nsize\n,\na\n[\nu\n].\nsize\n))\n{\nauto\n[\nz\n,\nw\n]\n=\ncut\n(\nv\n);\nreturn\nmerge\n(\nmerge\n(\nu\n,\nz\n),\nmerge\n(\nw\n,\ny\n));\n}\nelse\n{\nreturn\nmerge\n(\nu\n,\nmerge\n(\nv\n,\ny\n));\n}\n}\nelse\nif\n(\ntoo_heavy\n(\na\n[\ny\n].\nsize\n,\na\n[\nx\n].\nsize\n))\n{\nauto\n[\nu\n,\nv\n]\n=\ncut\n(\ny\n);\nif\n(\ntoo_heavy\n(\na\n[\nu\n].\nsize\n+\na\n[\nx\n].\nsize\n,\na\n[\nv\n].\nsize\n))\n{\nauto\n[\nz\n,\nw\n]\n=\ncut\n(\nu\n);\nreturn\nmerge\n(\nmerge\n(\nx\n,\nz\n),\nmerge\n(\nw\n,\nv\n));\n}\nelse\n{\nreturn\nmerge\n(\nmerge\n(\nx\n,\nu\n),\nv\n);\n}\n}\nelse\n{\nreturn\njoin\n(\nx\n,\ny\n);\n}\n}\nstd\n::\npair\n<\nint\n,\nint\n>\nsplit\n(\nint\nx\n,\nint\nk\n)\n{\nif\n(!\nx\n)\nreturn\n{\n0\n,\n0\n};\nif\n(!\nk\n)\nreturn\n{\n0\n,\nx\n};\nif\n(\nk\n==\na\n[\nx\n].\nsize\n)\nreturn\n{\nx\n,\n0\n};\nauto\n[\nu\n,\nv\n]\n=\ncut\n(\nx\n);\nif\n(\nk\n<=\na\n[\nu\n].\nsize\n)\n{\nauto\n[\nw\n,\nz\n]\n=\nsplit\n(\nu\n,\nk\n);\nreturn\n{\nw\n,\nmerge\n(\nz\n,\nv\n)};\n}\nelse\n{\nauto\n[\nw\n,\nz\n]\n=\nsplit\n(\nv\n,\nk\n-\na\n[\nu\n].\nsize\n);\nreturn\n{\nmerge\n(\nu\n,\nw\n),\nz\n};\n}\n}\nint\nfind\n(\nint\nu\n,\nint\nk\n)\n{\nif\n(\na\n[\nu\n].\nsize\n==\n1\n)\nreturn\nu\n;\npushdown\n(\nu\n);\nif\n(\nk\n<=\na\n[\na\n[\nu\n].\nls\n].\nsize\n)\nreturn\nfind\n(\na\n[\nu\n].\nls\n,\nk\n);\nelse\nreturn\nfind\n(\na\n[\nu\n].\nrs\n,\nk\n-\na\n[\na\n[\nu\n].\nls\n].\nsize\n);\n}\nint\nbuild\n(\nint\nn\n)\n{\nif\n(\nn\n==\n1\n)\nreturn\nnewleaf\n();\nint\nx\n=\nbuild\n(\nn\n/\n2\n);\nint\ny\n=\nbuild\n(\nn\n-\nn\n/\n2\n);\nreturn\njoin\n(\nx\n,\ny\n);\n}\nint\nmain\n()\n{\nstd\n::\nios\n::\nsync_with_stdio\n(\nfalse\n),\nstd\n::\ncin\n.\ntie\n(\n0\n);\nstd\n::\ncin\n>>\nn\n>>\nq\n;\nint\nrt\n=\nbuild\n(\nn\n);\nint\nlastans\n=\n0\n;\nfor\n(\nint\ni\n=\n1\n;\ni\n<=\nq\n;\ni\n++)\n{\nint\no\n;\nstd\n::\ncin\n>>\no\n;\nif\n(\no\n==\n1\n)\n{\nint\np\n;\nstd\n::\ncin\n>>\np\n;\np\n=\n(\np\n+\nlastans\n-\n1\n)\n%\nn\n+\n1\n;\nauto\n[\nA\n,\nB\n]\n=\nsplit\n(\nrt\n,\np\n);\nsetT\n(\nA\n,\nid\n[\ni\n]\n=\nnewtag\n(\ni\n));\nrt\n=\nmerge\n(\nA\n,\nB\n);\n}\nelse\nif\n(\no\n==\n2\n)\n{\nint\np\n;\nstd\n::\ncin\n>>\np\n;\np\n=\n(\np\n+\nlastans\n-\n1\n)\n%\nn\n+\n1\n;\nauto\n[\nA\n,\nB\n]\n=\nsplit\n(\nrt\n,\np\n);\nsetR\n(\nA\n);\nrt\n=\nmerge\n(\nA\n,\nB\n);\n}\nelse\nif\n(\no\n==\n3\n)\n{\nint\nx\n;\nstd\n::\ncin\n>>\nx\n;\nx\n=\n(\nx\n+\nlastans\n-\n1\n)\n%\nq\n+\n1\n;\na\n[\nid\n[\nx\n]].\nexit\n=\n0\n;\n}\nint\np\n;\nstd\n::\ncin\n>>\np\n;\np\n=\n(\np\n+\nlastans\n-\n1\n)\n%\nn\n+\n1\n;\nint\nu\n=\nfind\n(\nrt\n,\np\n);\nstd\n::\ncout\n<<\n(\nlastans\n=\nget_val\n(\nu\n))\n<<\n'\\n'\n;\n}\nreturn\n0\n;\n}"
}