{
    "contest_id": "2107",
    "problem_index": "F",
    "title": "F2. Cycling (Hard Version)",
    "description": "This is the hard version of the problem. The difference between the versions is that in this version, 1 ≤ n ≤ 10 6 and you need to output the answer for each prefix. You can hack only if you solved all versions of this problem. Leo works as a programmer in the city center, and his lover teaches at a high school in the suburbs. Every weekend, Leo would ride his bike to the suburbs to spend a nice weekend with his lover. There are n cyclists riding in front of Leo on this road right now. They are numbered 1 , 2 , … , n from front to back. Initially, Leo is behind the n -th cyclist. The i -th cyclist has an agility value a i . Leo wants to get ahead of the 1 -st cyclist. Leo can take the following actions as many times as he wants: Assuming that the first person in front of Leo is cyclist i , he can go in front of cyclist i for a cost of a i . This puts him behind cyclist i − 1 . Using his super powers, swap a i and a j ( 1 ≤ i < j ≤ n ) for a cost of ( j − i ) . Leo wants to know the minimum cost to get in front of the 1 -st cyclist. In addition, he wants to know the answer for each 1 ≤ i ≤ n , [ a 1 , a 2 , … , a i ] as the original array. The problems of different i are independent. To be more specific, in the i -th problem, Leo starts behind the i -th cyclist instead of the n -th cyclist, and cyclists numbered i + 1 , i + 2 , … , n are not present.",
    "input": "Input Each test contains multiple test cases. The first line contains the number of test cases t ( 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains a positive integer n ( 1 ≤ n ≤ 10 6 ), representing the number of the cyclists. The second line of each test case contains n integers a 1 , … , a n ( 1 ≤ a i ≤ 10 9 ). It is guaranteed that the sum of n over all test cases does not exceed 10 6 .",
    "output": "Output For each test case, print n integers, the answers for the array [ a 1 , a 2 , … , a i ] for each i = 1 , 2 , … n in this order.",
    "example": "Example\nInput\nCopy\n4\n3\n1 2 4\n4\n1 1 1 1\n2\n1 2\n4\n4 1 3 2\nOutput\nCopy\n1 3 7\n1 2 3 4\n1 3\n4 3 6 8",
    "note": "Note In the first test case, one possible way to move from the position behind the n -th cyclist to the position in front of the 1 -st cyclist is: Leo swaps a 2 ( i = 2 ) and a 3 ( j = 3 ) , then the array becomes [ 1 , 4 , 2 ] ; it costs j − i = 3 − 2 = 1 . Leo is behind the 3 -rd cyclist and moves behind the 2 -nd cyclist; it costs a 3 = 2 . Leo swaps a 1 ( i = 1 ) and a 2 ( j = 2 ) , then the array becomes [ 4 , 1 , 2 ] ; it costs j − i = 2 − 1 = 1 . Leo is behind the 2 -nd cyclist and moves behind the 1 -st cyclist; it costs a 2 = 1 . Leo swaps a 1 ( i = 1 ) and a 2 ( j = 2 ) , then the array becomes [ 1 , 4 , 2 ] ; it costs j − i = 2 − 1 = 1 . Leo moves ahead of the 1 -st cyclist; it costs a 1 = 1 . So the total cost is 1 + 2 + 1 + 1 + 1 + 1 = 7 . It can be proved that 7 is the minimum cost. In the second test case, to move ahead of the 1 -st cyclist from the position behind the n -th cyclist, Leo should not swap anyone's agility value. The total cost is 1 + 1 + 1 + 1 = 4 .",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "*2800"
    ],
    "editorial_content": null
}