{
    "contest_id": "2107",
    "problem_index": "C",
    "title": "C. Maximum Subarray Sum",
    "description": "You are given an array a 1 , a 2 , … , a n a 1 , a 2 , … , a n of length n n and a positive integer k k , but some parts of the array a a are missing. Your task is to fill the missing part so that the maximum subarray sum ∗ ∗ of a a is exactly k k , or report that no solution exists. Formally, you are given a binary string s s and a partially filled array a a , where: If you remember the value of a i a i , s i = 1 s i = 1 to indicate that, and you are given the real value of a i a i . If you don't remember the value of a i a i , s i = 0 s i = 0 to indicate that, and you are given a i = 0 a i = 0 . All the values that you remember satisfy | a i | ≤ 10 6 | a i | ≤ 10 6 . However, you may use values up to 10 18 10 18 to fill in the values that you do not remember. It can be proven that if a solution exists, a solution also exists satisfying | a i | ≤ 10 18 | a i | ≤ 10 18 . ∗ ∗ The maximum subarray sum of an array a a of length n n , i.e. a 1 , a 2 , … a n a 1 , a 2 , … a n is defined as max 1 ≤ i ≤ j ≤ n S ( i , j ) max 1 ≤ i ≤ j ≤ n S ( i , j ) where S ( i , j ) = a i + a i + 1 + … + a j S ( i , j ) = a i + a i + 1 + … + a j .",
    "input": "Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 10 4 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains two numbers n , k n , k ( 1 ≤ n ≤ 2 ⋅ 10 5 , 1 ≤ k ≤ 10 12 1 ≤ n ≤ 2 ⋅ 10 5 , 1 ≤ k ≤ 10 12 ). The second line of each test case contains a binary ( 01 01 ) string s s of length n n . The third line of each test case contains n n numbers a 1 , a 2 , … , a n a 1 , a 2 , … , a n ( | a i | ≤ 10 6 | a i | ≤ 10 6 ). If s i = 0 s i = 0 , then it's guaranteed that a i = 0 a i = 0 . It is guaranteed that the sum of n n over all test cases does not exceed 2 ⋅ 10 5 2 ⋅ 10 5 .",
    "output": "Output For each test case, first output Yes Yes if a solution exists or No No if no solution exists. You may print each character in either case, for example YES YES and yEs yEs will also be accepted. If there's at least one solution, print n n numbers a 1 , a 2 , … , a n a 1 , a 2 , … , a n on the second line. | a i | ≤ 10 18 | a i | ≤ 10 18 must hold.",
    "example": "Example\nInput\nCopy\n10\n3 5\n011\n0 0 1\n5 6\n11011\n4 -3 0 -2 1\n4 4\n0011\n0 0 -4 -5\n6 12\n110111\n1 2 0 5 -1 9\n5 19\n00000\n0 0 0 0 0\n5 19\n11001\n-8 6 0 0 -5\n5 10\n10101\n10 0 10 0 10\n1 1\n1\n0\n3 5\n111\n3 -1 3\n4 5\n1011\n-2 0 1 -5\nOutput\nCopy\nYes\n4 0 1\nYes\n4 -3 5 -2 1\nYes\n2 2 -4 -5\nNo\nYes\n5 1 9 2 2\nYes\n-8 6 6 7 -5\nYes\n10 -20 10 -20 10\nNo\nYes\n3 -1 3\nYes\n-2 4 1 -5",
    "note": "Note In test case 1 1 , only the first position is not filled. We can fill it with 4 4 to get the array [ 4 , 0 , 1 ] [ 4 , 0 , 1 ] which has maximum subarray sum of 5 5 . In test case 2 2 , only the third position is not filled. We can fill it with 5 5 to get the array [ 4 , − 3 , 5 , − 2 , 1 ] [ 4 , − 3 , 5 , − 2 , 1 ] . Here the maximum subarray sum comes from the subarray [ 4 , − 3 , 5 ] [ 4 , − 3 , 5 ] and it is 6 6 , as required. In test case 3 3 , the first and second positions are unfilled. We can fill both with 2 2 to get the array [ 2 , 2 , − 4 , − 5 ] [ 2 , 2 , − 4 , − 5 ] which has a maximum subarray sum of 4 4 . Note that other outputs are also possible such as [ 0 , 4 , − 4 , − 5 ] [ 0 , 4 , − 4 , − 5 ] . In test case 4 4 , it is impossible to get a valid array. For example, if we filled the third position with 0 0 , we get [ 1 , 2 , 0 , 5 , − 1 , 9 ] [ 1 , 2 , 0 , 5 , − 1 , 9 ] , but this has a maximum subarray sum of 16 16 , not 12 12 as required.",
    "tags": [
        "binary search",
        "constructive algorithms",
        "dp",
        "implementation",
        "math",
        "*1500"
    ],
    "editorial_content": null
}