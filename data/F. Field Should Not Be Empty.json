{
    "contest_id": "1905",
    "problem_index": "F",
    "title": "F. Field Should Not Be Empty",
    "description": "You are given a permutation † † p p of length n n . We call index x x good if for all y < x y < x it holds that p y < p x p y < p x and for all y > x y > x it holds that p y > p x p y > p x . We call f ( p ) f ( p ) the number of good indices in p p . You can perform the following operation: pick 2 2 distinct indices i i and j j and swap elements p i p i and p j p j . Find the maximum value of f ( p ) f ( p ) after applying the aforementioned operation exactly once . † † A permutation of length n n is an array consisting of n n distinct integers from 1 1 to n n in arbitrary order. For example, [ 2 , 3 , 1 , 5 , 4 ] [ 2 , 3 , 1 , 5 , 4 ] is a permutation, but [ 1 , 2 , 2 ] [ 1 , 2 , 2 ] is not a permutation ( 2 2 appears twice in the array), and [ 1 , 3 , 4 ] [ 1 , 3 , 4 ] is also not a permutation ( n = 3 n = 3 but there is 4 4 in the array).",
    "input": "Input Each test consists of multiple test cases. The first line of contains a single integer t t ( 1 ≤ t ≤ 2 ⋅ 10 4 1 ≤ t ≤ 2 ⋅ 10 4 ) — the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer n n ( 2 ≤ n ≤ 2 ⋅ 10 5 2 ≤ n ≤ 2 ⋅ 10 5 ) — the length of the permutation p p . The second line of each test case contain n n distinct integers p 1 , p 2 , … , p n p 1 , p 2 , … , p n ( 1 ≤ p i ≤ n 1 ≤ p i ≤ n ) — the elements of the permutation p p . It is guaranteed that sum of n n over all test cases does not exceed 2 ⋅ 10 5 2 ⋅ 10 5 .",
    "output": "Output For each test case, output a single integer — the maximum value of f ( p ) f ( p ) after performing the operation exactly once.",
    "example": "Example\nInput\nCopy\n5\n5\n1 2 3 4 5\n5\n2 1 3 4 5\n7\n2 1 5 3 7 6 4\n6\n2 3 5 4 1 6\n7\n7 6 5 4 3 2 1\nOutput\nCopy\n3\n5\n2\n3\n2",
    "note": "Note In the first test case, p = [ 1 , 2 , 3 , 4 , 5 ] p = [ 1 , 2 , 3 , 4 , 5 ] and f ( p ) = 5 f ( p ) = 5 which is already maximum possible. But must perform the operation anyway. We can get f ( p ) = 3 f ( p ) = 3 by choosing i = 1 i = 1 and j = 2 j = 2 which makes p = [ 2 , 1 , 3 , 4 , 5 ] p = [ 2 , 1 , 3 , 4 , 5 ] . In the second test case, we can transform p p into [ 1 , 2 , 3 , 4 , 5 ] [ 1 , 2 , 3 , 4 , 5 ] by choosing i = 1 i = 1 and j = 2 j = 2 . Thus f ( p ) = 5 f ( p ) = 5 .",
    "tags": [
        "brute force",
        "data structures",
        "divide and conquer",
        "*2600"
    ],
    "editorial_content": null
}