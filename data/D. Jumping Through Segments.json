{
    "contest_id": "1907",
    "problem_index": "D",
    "title": "D. Jumping Through Segments",
    "description": "Polycarp is designing a level for a game. The level consists of n n segments on the number line, where the i i -th segment starts at the point with coordinate l i l i and ends at the point with coordinate r i r i . The player starts the level at the point with coordinate 0 0 . In one move, they can move to any point that is within a distance of no more than k k . After their i i -th move, the player must land within the i i -th segment, that is, at a coordinate x x such that l i ≤ x ≤ r i l i ≤ x ≤ r i . This means: After the first move, they must be inside the first segment (from l 1 l 1 to r 1 r 1 ); After the second move, they must be inside the second segment (from l 2 l 2 to r 2 r 2 ); ... After the n n -th move, they must be inside the n n -th segment (from l n l n to r n r n ). The level is considered completed if the player reaches the n n -th segment, following the rules described above. After some thought, Polycarp realized that it is impossible to complete the level with some values of k k . Polycarp does not want the level to be too easy, so he asks you to determine the minimum integer k k with which it is possible to complete the level.",
    "input": "Input The first line contains a single integer t t ( 1 ≤ t ≤ 10 4 1 ≤ t ≤ 10 4 )—the number of test cases. Descriptions of the test cases follow. The first line of each test case contains a single integer n n ( 1 ≤ n ≤ 2 ⋅ 10 5 1 ≤ n ≤ 2 ⋅ 10 5 )—the number of segments in the level. The following n n lines. The i i -th line contain two integers l i l i and r i r i ( 0 ≤ l i ≤ r i ≤ 10 9 0 ≤ l i ≤ r i ≤ 10 9 )—the boundaries of the i i -th segment. Segments may intersect. It is guaranteed that the sum of n n over all test cases does not exceed 2 ⋅ 10 5 2 ⋅ 10 5 .",
    "output": "Output For each test case, output a single integer—the minimum value of k k with which it is possible to complete the level.",
    "example": "Example\nInput\nCopy\n4\n5\n1 5\n3 4\n5 6\n8 10\n0 1\n3\n0 2\n0 1\n0 3\n3\n3 8\n10 18\n6 11\n4\n10 20\n0 5\n15 17\n2 2\nOutput\nCopy\n7\n0\n5\n13",
    "note": "Note In the third example, the player can make the following moves: Move from point 0 0 to point 5 5 ( 3 ≤ 5 ≤ 8 3 ≤ 5 ≤ 8 ); Move from point 5 5 to point 10 10 ( 10 ≤ 10 ≤ 18 10 ≤ 10 ≤ 18 ); Move from point 10 10 to point 7 7 ( 6 ≤ 7 ≤ 11 6 ≤ 7 ≤ 11 ). Note that for the last move, the player could have chosen not to move and still complete the level.",
    "tags": [
        "binary search",
        "constructive algorithms",
        "*1400"
    ],
    "editorial_content": null
}