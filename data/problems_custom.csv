contest_id,problem_index,title,description,input,output,example,note,tags,editorial_content
4,A,A. Watermelon,,Input The first (and the only) input line contains integer number w ( 1 ≤ w ≤ 100 ) — the weight of the watermelon bought by the boys.,"Output Print YES , if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",,"Note For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).","brute force, math, *800",
2102,A,A. Dinner Time,,"Input Each test contains multiple test cases. The first line contains the number of test cases t ( 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first and only line of each test case contains four integers n , m , p , and q ( 1 ≤ p ≤ n ≤ 100 , 1 ≤ q , m ≤ 100 ) — the length of the array, the sum of elements, the length of a segment, and the sum of a segment, respectively.","Output For each test case, output "" YES "" (without quotes) if there exists an array satisfying the above conditions, and "" NO "" (without quotes) otherwise. You can output "" YES "" and "" NO "" in any case (for example, strings "" yES "", "" yes "", and "" Yes "" will all be recognized as valid responses).",,"Note In the first test case, an example of an array satisfying the condition is [ 1 , 0 , 1 ] . This is because: a 1 + a 2 + a 3 = 1 + 0 + 1 = 2 = m a 1 + a 2 = 1 + 0 = 1 = q a 2 + a 3 = 0 + 1 = 1 = q In the second test case, the only array satisfying the condition is [ 1 ] . In the third test case, an example of an array satisfying the condition is [ − 2 , 5 , − 2 , 5 , − 2 ] . In the fourth test case, it can be proven that there is no array satisfying the condition.","constructive algorithms, math, *900",
2116,A,A. Gellyfish and Tricolor Pansy,,"Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 10 4 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first and only line of each test case contains four integers a a , b b , c c , d d ( 1 ≤ a , b , c , d ≤ 10 9 1 ≤ a , b , c , d ≤ 10 9 ) — the HP of Gellyfish, the HP of Flower, the HP of Gellyfish's knight, and the HP of Flower's knight, respectively.","Output For each test case, if Flower will win, output ""Flower"", otherwise output ""Gellyfish"".",,"Note In the first test case, Gellyfish has only 1 1 HP. Therefore, no matter what Gellyfish does in the first round, Flower's knight will attack Gellyfish in the second round, allowing Flower to win. In the second test case, Flower's knight has only 1 1 HP. Gellyfish will attack Flower's knight in the first round. Then Flower's knight will no longer be able to attack, allowing Gellyfish to win.","games, greedy, *800",
2121,A,A. Letter Home,,"InputEach test consists of multiple test cases. The first line contains a single integer tt (1≤t≤10001≤t≤1000) — the number of test cases. The description of the test cases follows.The first line of each test case contains two integers nn and ss (1≤n≤101≤n≤10, 1≤s≤1001≤s≤100) — the number of positions to visit and the starting position. The second line of each test case contains nn integers x1,x2,…,xnx1,x2,…,xn (1≤xi≤1001≤xi≤100). It is guaranteed that for all 1≤i<n1≤i<n, it holds that xi<xi+1xi<xi+1.","OutputFor each test case, output the minimum number of steps in any successful sequence of steps.",,"NoteIn the first test case, no steps need to be taken, so the only visited position will be 11. In the second test case, the following path can be taken: 2→12→1. The number of steps is 11. In the third test case, the following path can be taken: 1→21→2. The number of steps is 11.In the fifth test case, the following path can be taken: 2→1→2→32→1→2→3. The number of steps is 33.","brute force, math",
2107,A,A. LRC and VIP,,"Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 500 1 ≤ t ≤ 500 ). The description of the test cases follows. The first line of each test case contains an integer n n ( 2 ≤ n ≤ 100 2 ≤ n ≤ 100 ). The second line of each test case contains n n integers a 1 , a 2 , … , a n a 1 , a 2 , … , a n ( 1 ≤ a i ≤ 10 4 1 ≤ a i ≤ 10 4 ).","Output For each test case, first output Yes if a solution exists or No if no solution exists. You may print each character in either case, for example YES and yEs will also be accepted. Only when there is a solution, output n integers on the second line. The i -th number should be either 1 or 2 . 1 represents that the element belongs to sequence B and 2 represents that the element belongs to sequence C . You should guarantee that 1 and 2 both appear at least once.",,"Note In the first test case, B = [ 51 , 9 ] and C = [ 1 , 20 ] . You can verify gcd ( B 1 , B 2 ) = 3 ≠ 1 = gcd ( C 1 , C 2 ) . In the second test case, it is impossible to find a solution. For example, suppose you distributed the first 3 elements to array B and then the last element to array C . You have B = [ 5 , 5 , 5 ] and C = [ 5 ] , but gcd ( B 1 , B 2 , B 3 ) = 5 = gcd ( C 1 ) . Hence it is invalid.","greedy, number theory, *800",
2112,A,A. Race,,"InputThe first line contains a single integer tt (1≤t≤10001≤t≤1000) — the number of test cases.The only line of each test case contains three integers aa, xx, yy (1≤a,x,y≤1001≤a,x,y≤100). Points aa, xx, and yy are pairwise distinct.","OutputFor each test case, print ""YES"" (case insensitive) if Bob can choose an integer point that is guarantee to get to the prize faster, regardless of where it appears. Otherwise, print ""NO"" (case insensitive).",,"NoteIn the first example, Bob can choose point 44. If the prize will be at point xx, then Bob's distance is |4−3|=1|4−3|=1 and Alice's distance is |1−3|=2|1−3|=2. If the prize will be at point yy, then Bob's distance is |4−4|=0|4−4|=0 and Alice's distance is |1−4|=3|1−4|=3.In the second example, Bob can choose point 22. If the prize will be at point xx, then Bob's distance is |2−3|=1|2−3|=1 and Alice's distance is |5−3|=2|5−3|=2. If the prize will be at point yy, then Bob's distance is |2−1|=1|2−1|=1 and Alice's distance is |5−1|=4|5−1|=4. In the third example, Bob cannot choose a point to guarantee his victory.",math,
2113,A,A. Shashliks,,"Input Each test contains multiple test cases. The first line contains the number of test cases t ( 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The only line of each test case contains five integers k , a , b , x , and y ( 1 ≤ k , a , b , x , y ≤ 10 9 ) — the initial temperature of the grill, the required temperature for cooking the first and second types of shashlik, respectively, as well as the temperature drop after cooking the first and second types of shashlik, respectively.","Output For each test case, output a single integer — the maximum number of portions of shashlik that you can cook.",,"Note In the first test case, it is advantageous to cook 7 portions of the second type of shashlik; after that, the grill's temperature will be 3 degrees, and we can cook one more portion of the first type of shashlik. In the second test case, we cannot cook either type of shashlik because the grill is too cold. In the fourth test case, it is advantageous to cook 8 portions of the first type of shashlik; after that, it will be possible to cook another 2 portions of the second type of shashlik.","greedy, math, *800",
2114,A,A. Square Year,,"Input The first line of the input contains a single integer t ( 1 ≤ t ≤ 10 4 ) — the number of test cases. The following lines describe the test cases. The only line of each test case contains a string s , consisting of exactly 4 characters. Each character is a digit from 0 to 9 .","Output On a separate line for each test case, output: Two numbers a and b ( a , b ≥ 0 ) such that ( a + b ) 2 = s , if they exist. If there are multiple suitable pairs, you may output any of them. The number − 1 otherwise.",,,"binary search, brute force, math, *800",
2121,B,B. Above the Clouds,,"InputEach test consists of multiple test cases. The first line contains a single integer t (1≤t≤104) — the number of test cases. The description of the test cases follows.The first line of each test case contains a single integer n (3≤n≤105) — the length of the string s. The second line of each test case contains the string s of length n, consisting of lowercase letters of the Latin alphabet. It is guaranteed that the sum of n across all test cases does not exceed 2⋅105.","OutputFor each test case, output ""Yes"" if there exist three non-empty strings a, b, and c that satisfy the conditions, and ""No"" otherwise. You may output the answer in any case (upper or lower). For example, the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be recognized as positive answers.",,"NoteIn the first test case, there exist unique non-empty strings a, b, and c such that a+b+c=s. These are the strings a= ""a"", b= ""a"", and c= ""a"". The concatenation of strings a and c equals a+c= ""aa"". The string b is a substring of this string. In the sixth test case, one can choose a= ""a"", b= ""ab"", and c= ""b"". The concatenation of strings a and c equals a+c= ""ab"". The string b is a substring of this string. In the seventh test case, one can choose a= ""ab"", b= ""a"", and c= ""ca"". The concatenation of strings a and c equals a+c= ""abca"". The string b is a substring of this string.","constructive algorithms, greedy, strings",
2107,B,B. Apples in Boxes,,"Input Each test contains multiple test cases. The first line contains the number of test cases t ( 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains two integers n , k ( 2 ≤ n ≤ 10 5 , 1 ≤ k ≤ 10 9 ). The second line of each test case contains n integers a 1 , a 2 , … , a n ( 1 ≤ a i ≤ 10 9 ). It is guaranteed that the sum of n over all test cases does not exceed 10 5 .","Output For each test case, print ""Tom"" (without quotes) if Tom will win, or ""Jerry"" (without quotes) otherwise.",,"Note Note that neither player is necessarily playing an optimal strategy in the following games, just to give you an idea of how the game is going. In the first test case of the example, one possible situation is shown as follows. Tom takes an apple from the first box. The array a becomes [ 1 , 1 , 2 ] . Tom does not lose because max ( 1 , 1 , 2 ) − min ( 1 , 1 , 2 ) = 1 ≤ k . Jerry takes an apple from the first box as well. The array a becomes [ 0 , 1 , 2 ] . Jerry loses because max ( 0 , 1 , 2 ) − min ( 0 , 1 , 2 ) = 2 > k .","games, greedy, math, *1100",
2113,B,B. Good Start,,"Input Each test contains multiple test cases. The first line contains the number of test cases t ( 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains four integers w , h , a , and b ( 1 ≤ w , h , a , b ≤ 10 9 ) — the dimensions of the roof and the dimensions of the roofing sheets, respectively. The second line of each test case contains four integers x 1 , y 1 , x 2 , and y 2 ( − a + 1 ≤ x 1 , x 2 ≤ w − 1 , − b + 1 ≤ y 1 , y 2 ≤ h − 1 ) — the coordinates of the bottom left corners of the already placed roofing sheets. It is guaranteed that these sheets do not overlap.","Output For each test case, output "" Yes "" (without quotes) if it is possible to completely tile the roof without removing either of the two already placed tiles, and "" No "" (without quotes) otherwise. You can output the answer in any case (upper or lower). For example, the strings "" yEs "", "" yes "", "" Yes "", and "" YES "" will be recognized as positive responses.",,"Note In the first test case, it is possible to add 8 roofing sheets as follows: In the second test case, it is impossible to completely tile the roof:","constructive algorithms, math, *1200",
2114,B,B. Not Quite a Palindromic String,,"Input The first line contains an integer t t ( 1 ≤ t ≤ 10 4 1 ≤ t ≤ 10 4 ) — the number of test cases. The first line of each test case contains two integers n n and k k ( 2 ≤ n ≤ 2 ⋅ 10 5 2 ≤ n ≤ 2 ⋅ 10 5 , 0 ≤ k ≤ n 2 0 ≤ k ≤ n 2 , n n is even) — the length of the string and the required number of good pairs. The second line of each test case contains a binary string s s of length n n . It is guaranteed that the sum of n n across all test cases does not exceed 2 ⋅ 10 5 2 ⋅ 10 5 .","Output For each test case, output "" YES "" if there is a way to rearrange the characters of the string so that there are exactly k k good pairs, otherwise output "" NO "". You may output each letter in any case (lowercase or uppercase). For example, the strings "" yEs "", "" yes "", "" Yes "", and "" YES "" will be accepted as a positive answer.",,,"greedy, math, *900",
2112,B,B. Shrinking Array,,"InputThe first line contains one integer tt (1≤t≤2001≤t≤200) — the number of test cases.The first line of each test case contains one integer nn (2≤n≤10002≤n≤1000) — the size of the array aa.The second line contains nn integers a1,a2,…,ana1,a2,…,an (1≤ai≤1061≤ai≤106) — the array aa itself.","OutputFor each test case, output one integer — the minimum number of operations needed to make the array aa beautiful, or −1−1 if it is impossible to make it beautiful.",,"NoteIn the first test case, the given array is already beautiful, as |a2−a3|=|3−3|=0|a2−a3|=|3−3|=0.In the second test case, it is impossible to make the array beautiful, as applying the operation would reduce its size to less than two.In the third test case, you can, for example, choose a1a1 and a2a2 and replace them with the number 22. The resulting array [2,3,7][2,3,7] is beautiful.In the fourth test case, you can, for example, choose a2a2 and a3a3 and replace them with the number 33. The resulting array [1,3,2][1,3,2] is beautiful.","brute force, greedy",
2102,B,B. The Picky Cat,,"Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 10 4 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains a single integer n n ( 1 ≤ n ≤ 10 5 1 ≤ n ≤ 10 5 ) — the length of the array a a . The second line of each test case contains n n integers a 1 , a 2 , … , a n a 1 , a 2 , … , a n ( | a i | ≤ 10 6 | a i | ≤ 10 6 , | a i | ≠ | a j | | a i | ≠ | a j | ) — the elements of the array a a . It is guaranteed that the sum of n n over all test cases does not exceed 10 5 10 5 .","Output For each testcase, output "" YES "" if it is possible to make the element at index 1 1 become the median of the array, and "" NO "" otherwise. You can output the answer in any case (upper or lower). For example, the strings "" yEs "", "" yes "", "" Yes "", and "" YES "" will be recognized as positive responses.",,"Note In the first test case, a 1 = 2 a 1 = 2 is already the median of the array a = [ 2 , 3 , 1 ] a = [ 2 , 3 , 1 ] , so no operation is required. In the second test case, we can do two operations: one on index 2 2 , and one on index 5 5 . The array becomes [ 1 , − 2 , 3 , 4 , − 5 ] [ 1 , − 2 , 3 , 4 , − 5 ] , which has a median of 1 1 . In the third test case, if you do an operation on index 1 1 , the array will become [ − 4 , 2 , 0 , − 5 ] [ − 4 , 2 , 0 , − 5 ] , which has a median of − 4 − 4 . In the fourth test case, it can be proven that no sequence of operations can make the median of the array become 5 5 or − 5 − 5 .","implementation, sortings, *900",
2112,C,C. Coloring Game,,"InputThe first line contains a single integer t (1≤t≤1000) — the number of test cases.The first line of each test case contains a single integer n (3≤n≤5000).The second line contains n integers a1,a2,…,an (1≤a1≤a2≤⋯≤an≤105).Additional constraint on the input: the sum of n over all test cases doesn't exceed 5000.","OutputFor each test case, print a single integer — the number of ways that Alice can choose 3 elements in order to win regardless of Bob's actions.",,"NoteIn the first two test cases, no matter which three elements Alice chooses, Bob will be able to paint one element blue so that Alice does not win.In the third test case, Alice can choose any three elements. If Bob colors one of the red elements, the sum of red elements will be 14, and the sum of blue elements will be 7. If Bob chooses an uncolored element, the sum of red elements will be 21, and the sum of blue elements will be 7.In the fourth test case, Alice can choose either the 1-st, 3-rd and 4-th element, or the 2-nd, 3-rd and 4-th element.","binary search, brute force, greedy, two pointers",
2116,C,C. Gellyfish and Flaming Peony,,"Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 5000 1 ≤ t ≤ 5000 ). The description of the test cases follows. The first line of each test case contains a single integer n n ( 1 ≤ n ≤ 5000 1 ≤ n ≤ 5000 ) — the length of the array. The second line of each test case contains n n integers a 1 , a 2 , … , a n a 1 , a 2 , … , a n ( 1 ≤ a i ≤ 5000 1 ≤ a i ≤ 5000 ) — the elements of the array. It is guaranteed that the sum of n n over all test cases does not exceed 5000 5000 .","Output For each test case, output a single integer — the minimum number of operations to achieve her goal.",,"Note In the first test case, the following is a way that minimizes the number of operations: Choose i = 3 i = 3 and j = 2 j = 2 and replace a 3 a 3 with gcd ( a 3 , a 2 ) = gcd ( 30 , 20 ) = 10 gcd ( a 3 , a 2 ) = gcd ( 30 , 20 ) = 10 , then a a becomes [ 12 , 20 , 10 ] [ 12 , 20 , 10 ] . Choose i = 1 i = 1 and j = 3 j = 3 and replace a 1 a 1 with gcd ( a 1 , a 3 ) = gcd ( 12 , 10 ) = 2 gcd ( a 1 , a 3 ) = gcd ( 12 , 10 ) = 2 , then a a becomes [ 2 , 20 , 10 ] [ 2 , 20 , 10 ] . Choose i = 2 i = 2 and j = 1 j = 1 and replace a 2 a 2 with gcd ( a 2 , a 1 ) = gcd ( 20 , 2 ) = 2 gcd ( a 2 , a 1 ) = gcd ( 20 , 2 ) = 2 , then a a becomes [ 2 , 2 , 10 ] [ 2 , 2 , 10 ] . Choose i = 3 i = 3 and j = 1 j = 1 and replace a 3 a 3 with gcd ( a 3 , a 1 ) = gcd ( 10 , 2 ) = 2 gcd ( a 3 , a 1 ) = gcd ( 10 , 2 ) = 2 , then a a becomes [ 2 , 2 , 2 ] [ 2 , 2 , 2 ] .","brute force, dfs and similar, dp, math, number theory, shortest paths, *1500",
2107,C,C. Maximum Subarray Sum,,"Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 10 4 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains two numbers n , k n , k ( 1 ≤ n ≤ 2 ⋅ 10 5 , 1 ≤ k ≤ 10 12 1 ≤ n ≤ 2 ⋅ 10 5 , 1 ≤ k ≤ 10 12 ). The second line of each test case contains a binary ( 01 01 ) string s s of length n n . The third line of each test case contains n n numbers a 1 , a 2 , … , a n a 1 , a 2 , … , a n ( | a i | ≤ 10 6 | a i | ≤ 10 6 ). If s i = 0 s i = 0 , then it's guaranteed that a i = 0 a i = 0 . It is guaranteed that the sum of n n over all test cases does not exceed 2 ⋅ 10 5 2 ⋅ 10 5 .","Output For each test case, first output Yes Yes if a solution exists or No No if no solution exists. You may print each character in either case, for example YES YES and yEs yEs will also be accepted. If there's at least one solution, print n n numbers a 1 , a 2 , … , a n a 1 , a 2 , … , a n on the second line. | a i | ≤ 10 18 | a i | ≤ 10 18 must hold.",,"Note In test case 1 1 , only the first position is not filled. We can fill it with 4 4 to get the array [ 4 , 0 , 1 ] [ 4 , 0 , 1 ] which has maximum subarray sum of 5 5 . In test case 2 2 , only the third position is not filled. We can fill it with 5 5 to get the array [ 4 , − 3 , 5 , − 2 , 1 ] [ 4 , − 3 , 5 , − 2 , 1 ] . Here the maximum subarray sum comes from the subarray [ 4 , − 3 , 5 ] [ 4 , − 3 , 5 ] and it is 6 6 , as required. In test case 3 3 , the first and second positions are unfilled. We can fill both with 2 2 to get the array [ 2 , 2 , − 4 , − 5 ] [ 2 , 2 , − 4 , − 5 ] which has a maximum subarray sum of 4 4 . Note that other outputs are also possible such as [ 0 , 4 , − 4 , − 5 ] [ 0 , 4 , − 4 , − 5 ] . In test case 4 4 , it is impossible to get a valid array. For example, if we filled the third position with 0 0 , we get [ 1 , 2 , 0 , 5 , − 1 , 9 ] [ 1 , 2 , 0 , 5 , − 1 , 9 ] , but this has a maximum subarray sum of 16 16 , not 12 12 as required.","binary search, constructive algorithms, dp, implementation, math, *1500",
2102,C,C. Mex in the Grid,,Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 100 1 ≤ t ≤ 100 ). The description of the test cases follows. The first line of each test case contains a single integer n n ( 1 ≤ n ≤ 500 1 ≤ n ≤ 500 ) — the side length of the grid. It is guaranteed that the sum of n n over all test cases does not exceed 1000 1000 .,"Output For each test case, output n n lines, each containing n n integers representing the elements of the grid. If there are multiple answers, you can output any of them.",,"Note In the first test case, one valid arrangement is: 0 1 2 3 There are 9 9 subgrids in total, and the 4 4 of them with non-zero MEX are shown below: 0 values: [ 0 ] [ 0 ] — MEX: 1 1 0 1 values: [ 0 , 1 ] [ 0 , 1 ] — MEX: 2 2 0 2 values: [ 0 , 2 ] [ 0 , 2 ] — MEX: 1 1 0 1 2 3 values: [ 0 , 1 , 2 , 3 ] [ 0 , 1 , 2 , 3 ] — MEX: 4 4 The sum of MEX over all subgrids would be 1 + 2 + 1 + 4 = 8 1 + 2 + 1 + 4 = 8 . It can be proven that no other arrangements have a larger sum of MEX values.","constructive algorithms, *1300",
2114,C,C. Need More Arrays,,"Input The first line of input contains one integer t t ( 1 ≤ t ≤ 10 4 1 ≤ t ≤ 10 4 ) — the number of test cases. The first line of each test case contains one integer n n ( 1 ≤ n ≤ 2 ⋅ 10 5 1 ≤ n ≤ 2 ⋅ 10 5 ) — the length of the array. The second line of each test case contains n n integers a 1 , a 2 , … , a n a 1 , a 2 , … , a n ( 1 ≤ a i ≤ 10 6 1 ≤ a i ≤ 10 6 , a i ≤ a i + 1 a i ≤ a i + 1 ) — the elements of the array. It is guaranteed that the sum of n n across all test cases does not exceed 2 ⋅ 10 5 2 ⋅ 10 5 .","Output For each test case, output one integer — the maximum number of arrays that can be obtained by removing any (possibly zero) number of elements.",,"Note In the first example, you can remove a 3 a 3 and a 5 a 5 , then a = [ 1 , 2 , 4 , 6 ] a = [ 1 , 2 , 4 , 6 ] , the process of forming arrays for it is shown in the statement. In the second example, you need to remove a 2 a 2 , after which a = [ 1 , 3 ] a = [ 1 , 3 ] , and the arrays [ 1 ] [ 1 ] and [ 3 ] [ 3 ] will be written. In the third example, no removals are needed; for a = [ 1 , 2 , 2 , 4 ] a = [ 1 , 2 , 2 , 4 ] , the arrays [ 1 , 2 , 2 ] [ 1 , 2 , 2 ] and [ 4 ] [ 4 ] will be written.","dp, greedy, *1000",
1700,,A. Optimal Path,"A. Optimal Path time limit per test2 seconds memory limit per test256 megabytes You are given a table a of size n×m . We will consider the table rows numbered from top to bottom from 1 to n , and the columns numbered from left to right from 1 to m . We will denote a cell that is in the i -th row and in the j -th column as (i,j) . In the cell (i,j) there is written a number (i−1)⋅m+j , that is aij=(i−1)⋅m+j . A turtle initially stands in the cell (1,1) and it wants to come to the cell (n,m) . From the cell (i,j) it can in one step go to one of the cells (i+1,j) or (i,j+1) , if it exists. A path is a sequence of cells in which for every two adjacent in the sequence cells the following satisfies: the turtle can reach from the first cell to the second cell in one step. A cost of a path is the sum of numbers that are written in the cells of the path. For example, with n=2 and m=3 the table will look as shown above. The turtle can take the following path: (1,1)→(1,2)→(1,3)→(2,3) . The cost of such way is equal to a11+a12+a13+a23=12 . On the other hand, the paths (1,1)→(1,2)→(2,2)→(2,1) and (1,1)→(1,3) are incorrect, because in the first path the turtle can't make a step (2,2)→(2,1) , and in the second path it can't make a step (1,1)→(1,3) . You are asked to tell the turtle a minimal possible cost of a path from the cell (1,1) to the cell (n,m) . Please note that the cells (1,1) and (n,m) are a part of the way. Input The first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. The description of test cases follows. A single line of each test case contains two integers n and m ( 1≤n,m≤104 ) — the number of rows and columns of the table a respectively. Output For each test case output a single integer — a minimal possible cost of a path from the cell (1,1) to the cell (n,m) . Example input Copy 7 1 1 2 3 3 2 7 1 1 10 5 5 10000 10000 output Copy 1 12 13 28 55 85 500099995000 Note In the first test case the only possible path consists of a single cell (1,1) . The path with the minimal cost in the second test case is shown in the statement. In the fourth and the fifth test cases there is only one path from (1,1) to (n,m) . Both paths visit every cell in the table.",,,Input: 7 1 1 2 3 3 2 7 1 1 10 5 5 10000 10000 Output: 1 12 13 28 55 85 500099995000,,"constructive algorithms, greedy, math",
1700,,B. Palindromic Numbers,"B. Palindromic Numbers time limit per test2 seconds memory limit per test256 megabytes During a daily walk Alina noticed a long number written on the ground. Now Alina wants to find some positive number of same length without leading zeroes, such that the sum of these two numbers is a palindrome. Recall that a number is called a palindrome, if it reads the same right to left and left to right. For example, numbers 121,66,98989 are palindromes, and 103,239,1241 are not palindromes. Alina understands that a valid number always exist. Help her find one! Input The first line of input data contains an integer t ( 1≤t≤100 ) — the number of test cases. Next, descriptions of t test cases follow. The first line of each test case contains a single integer n ( 2≤n≤100000 ) — the length of the number that is written on the ground. The second line of contains the positive n -digit integer without leading zeroes — the number itself. It is guaranteed that the sum of the values n over all test cases does not exceed 100000 . Output For each of t test cases print an answer — a positive n -digit integer without leading zeros, such that the sum of the input integer and this number is a palindrome. We can show that at least one number satisfying the constraints exists. If there are multiple solutions, you can output any of them. Example input Copy 3 2 99 4 1023 3 385 output Copy 32 8646 604 Note In the first test case 99+32=131 is a palindrome. Note that another answer is 12 , because 99+12=111 is also a palindrome. In the second test case 1023+8646=9669 . In the third test case 385+604=989 .",,,Input: 3 2 99 4 1023 3 385 Output: 32 8646 604,,"constructive algorithms, implementation, math",
1700,,C. Helping the Nature,"C. Helping the Nature time limit per test2 seconds memory limit per test256 megabytes Little Leon lives in the forest. He has recently noticed that some trees near his favourite path are withering, while the other ones are overhydrated so he decided to learn how to control the level of the soil moisture to save the trees. There are n trees growing near the path, the current levels of moisture of each tree are denoted by the array a 1 , a 2 ,…, a n . Leon has learned three abilities which will help him to dry and water the soil. Choose a position i and decrease the level of moisture of the trees 1,2,…,i by 1 . Choose a position i and decrease the level of moisture of the trees i,i+1,…,n by 1 . Increase the level of moisture of all trees by 1 . Leon wants to know the minimum number of actions he needs to perform to make the moisture of each tree equal to 0 . Input The first line contains a single integer t ( 1≤t≤2⋅ 10 4 ) — the number of test cases. The description of t test cases follows. The first line of each test case contains a single integer n ( 1≤n≤200000 ). The second line of each test case contains n integers a 1 , a 2 ,…, a n ( − 10 9 ≤ a i ≤ 10 9 ) — the initial levels of trees moisture. It is guaranteed that the sum of n over all test cases doesn't exceed 200000 . Output For each test case output a single integer — the minimum number of actions. It can be shown that the answer exists. Example input Copy 4 3 -2 -2 -2 3 10 4 7 4 4 -4 4 -4 5 1 -2 3 -4 5 output Copy 2 13 36 33 Note In the first test case it's enough to apply the operation of adding 1 to the whole array 2 times. In the second test case you can apply the operation of decreasing 4 times on the prefix of length 3 and get an array 6,0,3 . After that apply the operation of decreasing 6 times on the prefix of length 1 and 3 times on the suffix of length 1 . In total, the number of actions will be 4+6+3=13 . It can be shown that it's impossible to perform less actions to get the required array, so the answer is 13 .",,,Input: 4 3 -2 -2 -2 3 10 4 7 4 4 -4 4 -4 5 1 -2 3 -4 5 Output: 2 13 36 33,,"constructive algorithms, data structures, greedy",
1700,,D. River Locks,"D. River Locks time limit per test2 seconds memory limit per test256 megabytes Recently in Divanovo, a huge river locks system was built. There are now n locks, the i -th of them has the volume of vi liters, so that it can contain any amount of water between 0 and vi liters. Each lock has a pipe attached to it. When the pipe is open, 1 liter of water enters the lock every second. The locks system is built in a way to immediately transfer all water exceeding the volume of the lock i to the lock i+1 . If the lock i+1 is also full, water will be transferred further. Water exceeding the volume of the last lock pours out to the river. The picture illustrates 5 locks with two open pipes at locks 1 and 3 . Because locks 1 , 3 , and 4 are already filled, effectively the water goes to locks 2 and 5 . Note that the volume of the i -th lock may be greater than the volume of the i+1 -th lock. To make all locks work, you need to completely fill each one of them. The mayor of Divanovo is interested in q independent queries. For each query, suppose that initially all locks are empty and all pipes are closed. Then, some pipes are opened simultaneously. For the j -th query the mayor asks you to calculate the minimum number of pipes to open so that all locks are filled no later than after tj seconds. Please help the mayor to solve this tricky problem and answer his queries. Input The first lines contains one integer n ( 1≤n≤200000 ) — the number of locks. The second lines contains n integers v1,v2,…,vn ( 1≤vi≤109 )) — volumes of the locks. The third line contains one integer q ( 1≤q≤200000 ) — the number of queries. Each of the next q lines contains one integer tj ( 1≤tj≤109 ) — the number of seconds you have to fill all the locks in the query j . Output Print q integers. The j -th of them should be equal to the minimum number of pipes to turn on so that after tj seconds all of the locks are filled. If it is impossible to fill all of the locks in given time, print −1 . Examples input Copy 5 4 1 5 4 1 6 1 6 2 3 4 5 output Copy -1 3 -1 -1 4 3 input Copy 5 4 4 4 4 4 6 1 3 6 5 2 4 output Copy -1 -1 4 4 -1 5 Note There are 6 queries in the first example test. In the queries 1,3,4 the answer is −1 . We need to wait 4 seconds to fill the first lock even if we open all the pipes. In the sixth query we can open pipes in locks 1 , 3 , and 4 . After 4 seconds the locks 1 and 4 are full. In the following 1 second 1 liter of water is transferred to the locks 2 and 5 . The lock 3 is filled by its own pipe. Similarly, in the second query one can open pipes in locks 1 , 3 , and 4 . In the fifth query one can open pipes 1,2,3,4 .",,,Input: 5 4 1 5 4 1 6 1 6 2 3 4 5 Output: -1 3 -1 -1 4 3,,"binary search, dp, greedy, math",
1700,,E. Serega the Pirate,"E. Serega the Pirate time limit per test2 seconds memory limit per test256 megabytes Little pirate Serega robbed a ship with puzzles of different kinds. Among all kinds, he liked only one, the hardest. A puzzle is a table of n rows and m columns, whose cells contain each number from 1 to n⋅m exactly once. To solve a puzzle, you have to find a sequence of cells in the table, such that any two consecutive cells are adjacent by the side in the table. The sequence can have arbitrary length and should visit each cell one or more times. For a cell containing the number i , denote the position of the first occurrence of this cell in the sequence as t i . The sequence solves the puzzle, if t 1 < t 2 <⋯< t nm . In other words, the cell with number x should be first visited before the cell with number x+1 for each x . Let's call a puzzle solvable, if there exists at least one suitable sequence. In one move Serega can choose two arbitrary cells in the table (not necessarily adjacent by the side) and swap their numbers. He would like to know the minimum number of moves to make his puzzle solvable, but he is too impatient. Thus, please tell if the minimum number of moves is 0 , 1 , or at least 2 . In the case, where 1 move is required, please also find the number of suitable cell pairs to swap. Input In the first line there are two whole positive numbers n,m ( 1≤n⋅m≤400000 ) — table dimensions. In the next n lines there are m integer numbers a i1 , a i2 ,…, a im ( 1≤ a ij ≤nm ). It is guaranteed that every number from 1 to nm occurs exactly once in the table. Output Let a be the minimum number of moves to make the puzzle solvable. If a=0 , print 0 . If a=1 , print 1 and the number of valid swaps. If a≥2 , print 2 . Examples input Copy 3 3 2 1 3 6 7 4 9 8 5 output Copy 0 input Copy 2 3 1 6 4 3 2 5 output Copy 1 3 input Copy 1 6 1 6 5 4 3 2 output Copy 2 Note In the first example the sequence (1,2),(1,1),(1,2),(1,3),(2,3),(3,3) , (2,3),(1,3),(1,2),(1,1),(2,1),(2,2),(3,2),(3,1) solves the puzzle, so the answer is 0 . The puzzle in the second example can't be solved, but it's solvable after any of three swaps of cells with values (1,5),(1,6),(2,6) . The puzzle from the third example requires at least two swaps, so the answer is 2 .",,,Input: 3 3 2 1 3 6 7 4 9 8 5 Output: 0,,"brute force, constructive algorithms",
1700,,F. Puzzle,"F. Puzzle time limit per test1 second memory limit per test256 megabytes Pupils Alice and Ibragim are best friends. It's Ibragim's birthday soon, so Alice decided to gift him a new puzzle. The puzzle can be represented as a matrix with 2 rows and n columns, every element of which is either 0 or 1 . In one move you can swap two values in neighboring cells. More formally, let's number rows 1 to 2 from top to bottom, and columns 1 to n from left to right. Also, let's denote a cell in row x and column y as (x,y) . We consider cells ( x 1 , y 1 ) and ( x 2 , y 2 ) neighboring if | x 1 − x 2 |+| y 1 − y 2 |=1 . Alice doesn't like the way in which the cells are currently arranged, so she came up with her own arrangement, with which she wants to gift the puzzle to Ibragim. Since you are her smartest friend, she asked you to help her find the minimal possible number of operations in which she can get the desired arrangement. Find this number, or determine that it's not possible to get the new arrangement. Input The first line contains an integer n ( 1≤n≤200000 ) — the number of columns in the puzzle. Following two lines describe the current arrangement on the puzzle. Each line contains n integers, every one of which is either 0 or 1 . The last two lines describe Alice's desired arrangement in the same format. Output If it is possible to get the desired arrangement, print the minimal possible number of steps, otherwise print −1 . Examples input Copy 5 0 1 0 1 0 1 1 0 0 1 1 0 1 0 1 0 0 1 1 0 output Copy 5 input Copy 3 1 0 0 0 0 0 0 0 0 0 0 0 output Copy -1 Note In the first example the following sequence of swaps will suffice: (2,1),(1,1) , (1,2),(1,3) , (2,2),(2,3) , (1,4),(1,5) , (2,5),(2,4) . It can be shown that 5 is the minimal possible answer in this case. In the second example no matter what swaps you do, you won't get the desired arrangement, so the answer is −1 .",,,Input: 5 0 1 0 1 0 1 1 0 0 1 1 0 1 0 1 0 0 1 1 0 Output: 5,,"constructive algorithms, dp, greedy",
2107,D,D. Apple Tree Traversing,,"Input Each test contains multiple test cases. The first line contains the number of test cases t ( 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains a number n ( 1 ≤ n ≤ 1.5 ⋅ 10 5 ). The following n − 1 lines of each test case contain two numbers u , v ( 1 ≤ u , v ≤ n ). It's guaranteed that the input forms a tree. It is guaranteed that the sum of n over all test cases does not exceed 1.5 ⋅ 10 5 .","Output For each test case, output the lexicographically largest sequence possible a 1 , a 2 , … , a | a | . It can be shown that | a | ≤ 3 ⋅ n .",,"Note In the first test case, we do the following steps: Choose the apple path ( 4 , 3 ) . This path consists of the nodes 4 , 1 , 3 , and each of them have an apple (so it is a valid apple path). d = 3 as there are 3 apples on this path. Append 3 , 4 , 3 in that order to our sequence a . Now, remove the apples from these 3 vertices. Only node 2 has an apple left. Choose the apple path ( 2 , 2 ) . This path only consists of the single node 2 . d = 1 as there is 1 apple on this path. Append 1 , 2 , 2 in that order to our sequence a and remove the apple from 2 . The final sequence is thus [ 3 , 4 , 3 , 1 , 2 , 2 ] . It can be shown this is the lexicographically largest sequence possible.","brute force, dfs and similar, greedy, implementation, trees, *2100",
2114,D,D. Come a Little Closer,,"Input The first line contains a single integer t ( 1 ≤ t ≤ 10 4 ) — the number of test cases. The first line of each test case contains a single integer n ( 1 ≤ n ≤ 2 ⋅ 10 5 ) — the number of monsters on the field. The following n lines contain two integers x i and y i ( 1 ≤ x i , y i ≤ 10 9 ) — the coordinates of the cell with the i -th monster. All pairs ( x i , y i ) are distinct. It is guaranteed that the sum of n across all test cases does not exceed 2 ⋅ 10 5 .","Output For each test case, output a single integer — the minimum cost to destroy all n monsters.",,"Note Below are examples of optimal moves, with the cells of the rectangle to be selected highlighted in green. Required move for the first example. Required move for the fifth example.","brute force, greedy, implementation, math, *1400",
2116,D,D. Gellyfish and Camellia Japonica,,"Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 10 4 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains two integers n n and q q ( 1 ≤ n , q ≤ 3 ⋅ 10 5 1 ≤ n , q ≤ 3 ⋅ 10 5 ) — the size of the array and the number of modifications. The second line of each test case contains n n integers b 1 , b 2 , … , b n b 1 , b 2 , … , b n ( 1 ≤ b i ≤ 10 9 1 ≤ b i ≤ 10 9 ) — the value of the array c c after the q q modifications. The following q q lines each contain three integers x i x i , y i y i , and z i z i ( 1 ≤ x i , y i , z i ≤ n 1 ≤ x i , y i , z i ≤ n ) — describing the i i -th modification. It is guaranteed that the sum of n n and the sum of q q over all test cases does not exceed 3 ⋅ 10 5 3 ⋅ 10 5 .","Output For each test case, if a a exists, output n n integers a 1 , a 2 , … , a n a 1 , a 2 , … , a n ( 0 ≤ a i ≤ 10 9 0 ≤ a i ≤ 10 9 ) in a single line. Otherwise, output ""-1"" in a single line. If there are multiple solutions, print any of them.",,"Note In the first test case, based on the given sequence of modifications, we know that b 1 = a 1 b 1 = a 1 and b 2 = min ( a 1 , a 2 ) b 2 = min ( a 1 , a 2 ) . Therefore, it is necessary that b 2 ≤ b 1 b 2 ≤ b 1 . However, for the given b b , we have b 1 < b 2 b 1 < b 2 . Therefore, there is no solution. In the second test case, we can see that the given c c becomes b b from a a after the given modifications, and c c is not changed at each modification.","constructive algorithms, dfs and similar, graphs, greedy, trees, *2100",
2102,D,D. Quartet Swapping,,"Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 1000 1 ≤ t ≤ 1000 ). The description of the test cases follows. The first line of each test case contains a single integer n n ( 4 ≤ n ≤ 2 ⋅ 10 5 4 ≤ n ≤ 2 ⋅ 10 5 ) — the length of permutation a a . The second line contains n n integers a 1 , a 2 , … , a n a 1 , a 2 , … , a n ( 1 ≤ a i ≤ n 1 ≤ a i ≤ n ) — the elements of permutation a a . It is guaranteed that the sum of n n over all test cases does not exceed 2 ⋅ 10 5 2 ⋅ 10 5 .","Output For each test case, output the lexicographically smallest permutation that can be obtained by applying the above operation any number of times.",,"Note In the first test case, an operation can be done on index i = 1 i = 1 , and the permutation will become [ 1 , 2 , 3 , 4 ] [ 1 , 2 , 3 , 4 ] , which is the lexicographically smallest permutation achievable. In the second test case, we can do the following sequence of operations: Do an operation on index i = 2 i = 2 . The permutation becomes [ 5 , 1 , 2 , 4 , 3 ] [ 5 , 1 , 2 , 4 , 3 ] . Do an operation on index i = 1 i = 1 . The permutation becomes [ 2 , 4 , 5 , 1 , 3 ] [ 2 , 4 , 5 , 1 , 3 ] . Do an operation on index i = 2 i = 2 . The permutation becomes [ 2 , 1 , 3 , 4 , 5 ] [ 2 , 1 , 3 , 4 , 5 ] .","data structures, greedy, sortings, *1800",
2112,D,D. Reachability and Tree,,"InputThe first line contains one integer t (1≤t≤104) — the number of test cases.The first line of each test case contains one integer n (2≤n≤2⋅105) — the number of vertices in the tree.The next n−1 lines describe the edges. The i-th line contains two integers ui and vi (1≤ui,vi≤n; ui≠vi) — the vertices connected by the i-th edge.It is guaranteed that the edges in each test case form an undirected tree and that the sum of n over all test cases does not exceed 2⋅105.","OutputFor each test case, print ""NO"" (case-insensitive) if it is impossible to direct all edges of the tree and obtain exactly n good pairs of vertices.Otherwise, print ""YES"" (case-insensitive) and then print n−1 pairs of integers ui and vi separated by spaces — the edges directed from ui to vi.The edges can be printed in any order. If there are multiple answers, output any.",,"NoteThe tree from the first test case and its possible directed version are shown in the legend above. In this version, there are exactly 5 good pairs of vertices: (3,5), (3,1), (3,2), (1,2), and (4,2).One possible directed version of the tree from the second test case is shown below: In the presented answer, there are exactly 5 good pairs of vertices: (2,1), (3,1), (4,1), (5,4), and (5,1).In the third test case, there are only two directed pairs of vertices, but for any direction of the edge, only one pair will be good.","constructive algorithms, dfs and similar, dp, trees",
2102,E,E. 23 Kingdom,,"Input Each test contains multiple test cases. The first line contains the number of test cases t ( 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains a single integer n ( 1 ≤ n ≤ 2 ⋅ 10 5 ) — the length of array a . The second line of each test case contains n integers a 1 , a 2 , … , a n ( 1 ≤ a i ≤ n ) — the elements of array a . It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10 5 .","Output For each test case, output a single integer representing the maximum possible beauty among all nice arrays.",,"Note In the first test case, if b = [ 1 , 2 , 1 , 2 ] , then d 1 ( b ) = 3 − 1 = 2 and d 2 ( b ) = 4 − 2 = 2 , resulting in a beauty of 2 + 2 = 4 . It can be proven that there are no nice arrays with a beauty greater than 4 . In the second test case, both b = [ 1 , 1 ] and b = [ 2 , 2 ] are valid solutions with a beauty of 1 . In the third test case, if b = [ 1 , 2 , 1 , 4 , 1 , 2 , 1 , 1 , 1 , 2 ] with d 1 ( b ) = 9 − 1 = 8 , d 2 ( b ) = 10 − 2 = 8 , and d 4 ( b ) = 0 , resulting in a beauty of 16 .","data structures, greedy, ternary search, two pointers, *2200",
2107,E,E. Ain and Apple Tree,,"Input Each test contains multiple test cases. The first line contains the number of test cases t ( 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains two numbers n , k ( 2 ≤ n ≤ 10 5 , 0 ≤ k ≤ 10 15 ). It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10 5 .","Output For each test case, first output Yes if a solution exists or No if no solution exists. You may print each character in either case, for example YES and yEs will also be accepted. If there's at least one solution, print n − 1 lines and each line contains two numbers u , v ( 1 ≤ u , v ≤ n ) represents the apple tree.",,"Note In the first test case, we can check that the weight is 0 . This satisfies the condition because k = 1 and so the absolute difference is only 1 . In the second test case, there exists no solution because there are no trees of 2 nodes with weights of either 1 , 2 or 3 .","binary search, constructive algorithms, greedy, math, trees, *2600",
2116,E,E. Gellyfish and Eternal Violet,,"Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 100 1 ≤ t ≤ 100 ). The description of the test cases follows. The first line of each test case contains three integers n n , m m , and p ′ ( 1 ≤ n ≤ 20 , 1 ≤ m ≤ 4000 , 0 ≤ p ′ ≤ 100 ) — the number of monsters, the number of rounds of attacks, and an integer representing the probability p = p ′ 100 that the Sword Sharpened with Tears shines. The second line of each test case contains n integers h 1 , h 2 , … , h n ( 1 ≤ h i ≤ 400 ) — the HP of the monsters. It is guaranteed that the sum of n over all test cases does not exceed 100 .","Output For each test case, output a single real number representing the probability that Gellyfish will reach her goal. Your answer is considered correct if its absolute or relative error does not exceed 10 − 6 . Formally, let your answer be a , and the jury's answer be b . Your answer is accepted if and only if | a − b | max ( 1 , | b | ) ≤ 10 − 6 .",,"Note In the first test case, Gellyfish will always attack whether the sword shines or not in the first round. If the sword shines in the first round, then Gellyfish can reach her goal after the attack in the first round. Otherwise, if the sword does not shine in the first round, she will attack monster 1 in the first round. For the second round: If the sword shines, since monster 1 was attacked in the first round, Gellyfish can't reach her goal. Otherwise, Gellyfish can attack monster 2 , allowing her to reach her goal. Therefore, the probability that Gellyfish can reach her goal is 10 % + ( 90 % ⋅ 90 % ) = 91 % . In the second test case, Gellyfish will only attack in the first round where the sword shines. It can be observed that the only way Gellyfish can't reach her goal is if the sword never shines in all 5 rounds. The probability that Gellyfish can reach her goal is 100 % − ( 80 % ) 5 = 67.232 % .","combinatorics, dp, greedy, *2700",
2114,E,E. Kirei Attacks the Estate,,"Input The first line contains an integer t ( 1 ≤ t ≤ 10 4 ) — the number of test cases. The following describes the test cases. The first line contains an integer n ( 2 ≤ n ≤ 2 ⋅ 10 5 ) — the number of vertices in the tree. The second line contains n integers a 1 , a 2 , … , a n ( 1 ≤ a i ≤ 10 9 ) — the dangers of the vertices. The next n − 1 lines contain the numbers v , u ( 1 ≤ v , u ≤ n , v ≠ u ) — the description of the edges of the tree. It is guaranteed that the sum of n across all test cases does not exceed 2 ⋅ 10 5 . It is also guaranteed that the given set of edges forms a tree.","Output For each test case, output n integers — the threat of each vertex.",,"Note The tree from the first test case is depicted in the statement, and the maximum variable-sign sums are achieved as follows: a 1 = 4 ; a 2 = 5 ; a 3 = 2 ; a 4 − a 3 + a 2 = 6 − 2 + 5 = 9 ; a 5 = 7 .","dfs and similar, dp, greedy, trees, *1400",
2112,E,E. Tree Colorings,,InputThe first line contains a single integer (1≤t≤105) — the number of test cases.The only line of each test case contains a single integer m (1≤m≤5⋅105).,"OutputFor each test case, print a single integer — the minimum number of vertices in a tree with exactly m beautiful colorings. If such a tree does not exist, print −1.",,"NoteIn the following notes, let g describe green color, b be blue, and y be yellow.In the first example, consider a simple tree with just 1 vertex. This tree has exactly 1 beautiful coloring: the root is green.In the second example, consider a simple tree with 2 vertices with a root at the 1-st vertex. There are exactly 3 beautiful colorings: [g,g], [g,b] and [g,y].In the third example, consider a bamboo tree with 3 vertices with a root at the 1-st vertex. There are exactly 5 beautiful colorings: [g,g,g], [g,g,b], [g,g,y], [g,b,b] and [g,y,y].In the fifth example, consider a tree with 3 vertices with a root at the 1-st vertex, and the other 2 vertices connected to it. There are exactly 9 beautiful colorings: [g,g,g], [g,g,b], [g,g,y], [g,b,g], [g,b,b], [g,b,y], [g,y,g], [g,y,b] and [g,y,y].","combinatorics, dp, graphs, math, trees",
2116,F,F. Gellyfish and Forget-Me-Not,,"Input Each test contains multiple test cases. The first line contains the number of test cases t ( 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains a single integer n ( 1 ≤ n ≤ 10 5 ) — the number of rounds of the game. The second line of each test case contains n integers a 1 , a 2 , … , a n ( 0 ≤ a i < 2 60 ). The third line of each test case contains n integers b 1 , b 2 , … , b n ( 0 ≤ b i < 2 60 ). The fourth line of each test case contains a binary string c of length n . It is guaranteed that the sum of n over all test cases does not exceed 10 5 .","Output For each test case, output a single integer — the final value of x after all n rounds.",,"Note In the first test case, there's only one round and Gellyfish is the active player of that round. Therefore, she will choose a 1 , and the final value of x is 0 . In the second test case, Flower will be the active player in both rounds. She will choose a 1 and b 2 , and the final value of x is a 1 ⊕ b 2 = 15 . Flower may also choose b 1 and a 2 instead for the same result of x = a 2 ⊕ b 1 = 15 . In the third test case, a 1 = b 1 so it doesn't matter what decision Gellyfish makes in the first round. In the second round: If Flower chooses a 2 , then x will become 7 . Gellyfish will choose b 3 in the third round, so the final value of x will be 4 . Otherwise, Flower chooses b 2 , then x will become 4 . Gellyfish will choose a 3 in the third round, so the final value of x will be 6 . Flower wants to maximize the final value of x , so Flower will choose b 2 in the second round. Therefore, the final value of x will be 6 .","bitmasks, greedy, math, *2900",
2102,F,F. Mani and Segments,,"Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 10 4 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains a single integer n n ( 1 ≤ n ≤ 2 ⋅ 10 5 1 ≤ n ≤ 2 ⋅ 10 5 ) — the length of permutation a a . The second line of each test case contains n n integers a 1 , a 2 , … , a n a 1 , a 2 , … , a n ( 1 ≤ a i ≤ n 1 ≤ a i ≤ n ) — the elements of permutation a a . It is guaranteed that the sum of n n over all test cases does not exceed 2 ⋅ 10 5 2 ⋅ 10 5 .","Output For each test case, output the number of cute non-empty subarrays of permutation a a .",,"Note In the first test case, all of the 6 6 non-empty subarrays are cute: [ 3 ] [ 3 ] : LIS ( [ 3 ] ) + LDS ( [ 3 ] ) = 1 + 1 = 2 LIS ⁡ ( [ 3 ] ) + LDS ⁡ ( [ 3 ] ) = 1 + 1 = 2 . [ 1 ] [ 1 ] : LIS ( [ 1 ] ) + LDS ( [ 1 ] ) = 1 + 1 = 2 LIS ⁡ ( [ 1 ] ) + LDS ⁡ ( [ 1 ] ) = 1 + 1 = 2 . [ 2 ] [ 2 ] : LIS ( [ 2 ] ) + LDS ( [ 2 ] ) = 1 + 1 = 2 LIS ⁡ ( [ 2 ] ) + LDS ⁡ ( [ 2 ] ) = 1 + 1 = 2 . [ 3 , 1 ] [ 3 , 1 ] : LIS ( [ 3 , 1 ] ) + LDS ( [ 3 , 1 ] ) = 1 + 2 = 3 LIS ⁡ ( [ 3 , 1 ] ) + LDS ⁡ ( [ 3 , 1 ] ) = 1 + 2 = 3 . [ 1 , 2 ] [ 1 , 2 ] : LIS ( [ 1 , 2 ] ) + LDS ( [ 1 , 2 ] ) = 2 + 1 = 3 LIS ⁡ ( [ 1 , 2 ] ) + LDS ⁡ ( [ 1 , 2 ] ) = 2 + 1 = 3 . [ 3 , 1 , 2 ] [ 3 , 1 , 2 ] : LIS ( [ 3 , 1 , 2 ] ) + LDS ( [ 3 , 1 , 2 ] ) = 2 + 2 = 4 LIS ⁡ ( [ 3 , 1 , 2 ] ) + LDS ⁡ ( [ 3 , 1 , 2 ] ) = 2 + 2 = 4 . In the second test case, one of the cute subarrays is [ 2 , 3 , 4 , 5 , 1 ] [ 2 , 3 , 4 , 5 , 1 ] as LIS ( [ 2 , 3 , 4 , 5 , 1 ] ) = 4 LIS ⁡ ( [ 2 , 3 , 4 , 5 , 1 ] ) = 4 and LDS ( [ 2 , 3 , 4 , 5 , 1 ] ) = 2 LDS ⁡ ( [ 2 , 3 , 4 , 5 , 1 ] ) = 2 , which satisfies 4 + 2 = 5 + 1 4 + 2 = 5 + 1 .","data structures, greedy, *2500",
2114,F,F. Small Operations,,"Input The first line of the input contains one integer t ( 1 ≤ t ≤ 10 4 ) — the number of test cases. The only line of each test case contains three integers x , y and k ( 1 ≤ x , y , k ≤ 10 6 ). It is guaranteed that the sum of x and the sum of y across all test cases does not exceed 10 8 .","Output For each test case, output − 1 if it is impossible to achieve x = y using the given operations, and the minimum number of required operations otherwise.",,,"binary search, brute force, dfs and similar, dp, math, number theory, sortings, *2000",
2112,F,F. Variables and Operations,,"InputThe first line contains two integers n and m (2 \le n \le 500; 1 \le m \le 4 \cdot 10^5) — the number of variables and operations, respectively.Then, m lines follow. The i-th of them contains three integers x_i, y_i, z_i (1 \le x_i, y_i \le n; x_i \ne y_i; 0 \le z_i \le 10^5) — the description of the i-th operation.The next line contains one integer q (1 \le q \le 1000) — the number of queries.Each query consists of two lines: the first line contains one integer k (0 \le k \le 10^9) — the maximum number of times you can choose a variable and decrease it by 1; the second line contains n integers a_1, a_2, \dots, a_n (0 \le a_i \le 10^9) — the initial values of the variables.","OutputFor each query, print a string of n zeroes and/or ones. The i-th character should be 1 if it is possible to obtain an i-unstable sequence, or 0 otherwise.",,"NoteConsider the first example. If the initial variable values are [20, 0, 15, 5], the resulting values will be [6, 0, 5, 5] with any order of operations. Decreasing the variables 10 times is not enough. However, if we can apply no more than 30 changes, we can decrease the 1-st variable by 2, and the 4-th variable by 25, we get initial values equal to [18, 0, 15, -20], and this sequence is 2-unstable and 3-unstable: if you apply the operations in the order they are given, you will get [-12, 0, 5, -20]; however, if you apply the operations in order [3, 2, 4, 1, 5], you will get [-12, -2, 5, -20]; and if you apply the operations in order [3, 4, 5, 1, 2], you will get [-12, -2, 3, -20].","graphs, greedy, shortest paths",
2107,F,F1. Cycling (Easy Version),,"Input Each test contains multiple test cases. The first line contains the number of test cases t t ( 1 ≤ t ≤ 10 3 1 ≤ t ≤ 10 3 ). The description of the test cases follows. The first line of each test case contains a positive integer n n ( 1 ≤ n ≤ 5 ⋅ 10 3 1 ≤ n ≤ 5 ⋅ 10 3 ), representing the number of the cyclists. The second line of each test case contains n n integers a 1 , … , a n a 1 , … , a n ( 1 ≤ a i ≤ 10 9 1 ≤ a i ≤ 10 9 ). It is guaranteed that the sum of n n over all test cases does not exceed 5 ⋅ 10 3 5 ⋅ 10 3 .","Output For each test case, print one integer representing the minimum cost for Leo to go from behind the n n -th cyclist to in front of the 1 1 -st cyclist.",,"Note In the first test case, one possible way to move from the position behind the n n -th cyclist to the position in front of the 1 1 -st cyclist is: Leo swaps a 2 a 2 ( i = 2 ) ( i = 2 ) and a 3 a 3 ( j = 3 ) ( j = 3 ) , then the array becomes [ 1 , 4 , 2 ] [ 1 , 4 , 2 ] ; it costs j − i = 3 − 2 = 1 j − i = 3 − 2 = 1 . Leo is behind the 3 3 -rd cyclist and moves behind the 2 2 -nd cyclist; it costs a 3 = 2 a 3 = 2 . Leo swaps a 1 a 1 ( i = 1 ) ( i = 1 ) and a 2 a 2 ( j = 2 ) ( j = 2 ) , then the array becomes [ 4 , 1 , 2 ] [ 4 , 1 , 2 ] ; it costs j − i = 2 − 1 = 1 j − i = 2 − 1 = 1 . Leo is behind the 2 2 -nd cyclist and moves behind the 1 1 -st cyclist; it costs a 2 = 1 a 2 = 1 . Leo swaps a 1 a 1 ( i = 1 ) ( i = 1 ) and a 2 a 2 ( j = 2 ) ( j = 2 ) , then the array becomes [ 1 , 4 , 2 ] [ 1 , 4 , 2 ] ; it costs j − i = 2 − 1 = 1 j − i = 2 − 1 = 1 . Leo moves ahead of the 1 1 -st cyclist; it costs a 1 = 1 a 1 = 1 . So the total cost is 1 + 2 + 1 + 1 + 1 + 1 = 7 1 + 2 + 1 + 1 + 1 + 1 = 7 . It can be proved that 7 7 is the minimum cost. In the second test case, to move ahead of the 1 1 -st cyclist from the position behind the n n -th cyclist, Leo should not swap anyone's agility value. The total cost is 1 + 1 + 1 + 1 = 4 1 + 1 + 1 + 1 = 4 .","binary search, brute force, dp, greedy, *2300",
2107,F,F2. Cycling (Hard Version),,"Input Each test contains multiple test cases. The first line contains the number of test cases t ( 1 ≤ t ≤ 10 4 ). The description of the test cases follows. The first line of each test case contains a positive integer n ( 1 ≤ n ≤ 10 6 ), representing the number of the cyclists. The second line of each test case contains n integers a 1 , … , a n ( 1 ≤ a i ≤ 10 9 ). It is guaranteed that the sum of n over all test cases does not exceed 10 6 .","Output For each test case, print n integers, the answers for the array [ a 1 , a 2 , … , a i ] for each i = 1 , 2 , … n in this order.",,"Note In the first test case, one possible way to move from the position behind the n -th cyclist to the position in front of the 1 -st cyclist is: Leo swaps a 2 ( i = 2 ) and a 3 ( j = 3 ) , then the array becomes [ 1 , 4 , 2 ] ; it costs j − i = 3 − 2 = 1 . Leo is behind the 3 -rd cyclist and moves behind the 2 -nd cyclist; it costs a 3 = 2 . Leo swaps a 1 ( i = 1 ) and a 2 ( j = 2 ) , then the array becomes [ 4 , 1 , 2 ] ; it costs j − i = 2 − 1 = 1 . Leo is behind the 2 -nd cyclist and moves behind the 1 -st cyclist; it costs a 2 = 1 . Leo swaps a 1 ( i = 1 ) and a 2 ( j = 2 ) , then the array becomes [ 1 , 4 , 2 ] ; it costs j − i = 2 − 1 = 1 . Leo moves ahead of the 1 -st cyclist; it costs a 1 = 1 . So the total cost is 1 + 2 + 1 + 1 + 1 + 1 = 7 . It can be proved that 7 is the minimum cost. In the second test case, to move ahead of the 1 -st cyclist from the position behind the n -th cyclist, Leo should not swap anyone's agility value. The total cost is 1 + 1 + 1 + 1 = 4 .","binary search, brute force, data structures, dp, greedy, *2800",
2114,G,G. Build an Array,,"Input The first line contains a single integer t ( 1 ≤ t ≤ 10 4 ) — the number of test cases. The descriptions of the test cases follow. The first line of each test case description contains two integers n and k ( 1 ≤ n ≤ 10 5 , n ≤ k ≤ 10 6 ) — the length of the resulting array and the number of operations. The second line contains n integers a i ( 1 ≤ a i ≤ 10 9 , a i − 1 ≠ a i ) — the elements of the resulting array. It is guaranteed that the sum of the values of n across all test cases does not exceed 10 5 .","Output For each test case, if there is no suitable sequence of operations of length k , output "" NO "". Otherwise, output "" YES "". You may output "" YES "" and "" NO "" in any case (for example, the strings "" yEs "", "" yes "", "" Yes "", and "" YES "" will be recognized as a positive answer).",,,"brute force, constructive algorithms, dp, greedy, math, number theory, *2200",
